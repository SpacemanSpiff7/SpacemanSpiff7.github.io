<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LA Traffic Collisions Dashboard | Simone Longo</title>
    <meta name="description" content="Interactive dashboard analyzing 620K+ LA traffic collision records (2010-2021) with map visualization, temporal analysis, and filtering.">

    <!-- Skip main site script -->
    <script>window.SKIP_MAIN_SCRIPT = true;</script>

    <!-- Preload critical resources -->
    <link rel="preload" href="../css/style.css" as="style">

    <!-- Stylesheets -->
    <link rel="stylesheet" href="../css/style.css">
    <link href="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.css" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500&family=Silkscreen:wght@400;700&display=swap" rel="stylesheet">

    <!-- External Libraries -->
    <script src="https://unpkg.com/maplibre-gl@3.6.2/dist/maplibre-gl.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <script src="https://unpkg.com/rbush@3.0.1/rbush.min.js"></script>

    <style>
        /* Override main site's scroll-snap and overflow:hidden for dashboard */
        html, body {
            overflow: visible !important;
            overflow-y: auto !important;
            height: auto !important;
            scroll-snap-type: none !important;
        }

        /* Unified Color Palette */
        :root {
            /* Collision Type Colors - muted for dark theme */
            --color-vehicle: #4a90d9;
            --color-pedestrian: #e05d5d;
            --color-motorcycle: #f0a040;
            --color-bicycle: #50b080;
            --color-other: #8090a0;

            /* Severity Colors */
            --color-severity-property: #6b7c8d;
            --color-severity-minor: #f4a940;
            --color-severity-severe: #e05d5d;
            --color-severity-fatal: #dc3545;
            --color-severity-unknown: #8090a0;

            /* Trend Colors */
            --color-trend-up: #e05d5d;
            --color-trend-down: #50b080;
            --color-trend-neutral: #8090a0;

            /* Time of Day Colors */
            --color-time-early-am: #2c3e50;
            --color-time-am-peak: #e67e22;
            --color-time-midday: #f1c40f;
            --color-time-pm-peak: #c0392b;
            --color-time-evening: #8e44ad;
            --color-time-late-night: #34495e;
        }

        /* Dashboard Container */
        .dashboard-container {
            max-width: 1920px;
            margin: 0 auto;
            padding: 2rem 2rem 3rem;
            background: var(--color-background);
        }

        .dashboard-header {
            text-align: center;
            margin-bottom: 2rem;
        }

        .dashboard-header h1 {
            font-family: 'Silkscreen', 'Courier New', monospace;
            font-size: clamp(2rem, 5vw, 3.5rem);
            color: #ffffff;
            text-shadow: 0 0 10px rgba(138, 43, 226, 0.4);
            margin-bottom: 0.5rem;
        }

        .subtitle {
            font-family: 'Silkscreen', 'Courier New', monospace;
            color: var(--color-text-secondary);
            font-size: 0.875rem;
        }

        .subtitle a {
            color: #00bfff;
            text-decoration: underline;
            cursor: pointer;
        }

        .subtitle a:hover {
            opacity: 0.8;
        }

        /* Data Quality Banner - Muted rust tones for dark theme */
        .data-quality-banner {
            background: linear-gradient(135deg, rgba(139, 74, 50, 0.15), rgba(139, 74, 50, 0.08));
            border: 1px solid rgba(139, 74, 50, 0.35);
            border-radius: var(--radius-lg);
            margin-bottom: 2rem;
            overflow: hidden;
        }

        .data-quality-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem 1.5rem;
            background: rgba(139, 74, 50, 0.1);
            cursor: pointer;
            user-select: none;
        }

        .data-quality-header:hover {
            background: rgba(139, 74, 50, 0.18);
        }

        .data-quality-title {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-weight: 600;
            color: #d4836b;
        }

        .data-quality-icon {
            font-size: 1.25rem;
        }

        .data-quality-toggle {
            background: none;
            border: none;
            font-size: 1.25rem;
            color: #d4836b;
            cursor: pointer;
            transition: transform 0.2s;
            padding: 0.25rem;
        }

        .data-quality-banner.expanded .data-quality-toggle {
            transform: rotate(180deg);
        }

        .data-quality-content {
            display: none;
            padding: 1.5rem;
            border-top: 1px solid rgba(139, 74, 50, 0.25);
        }

        .data-quality-banner.expanded .data-quality-content {
            display: block;
        }

        .data-quality-content h4 {
            color: var(--color-text);
            font-size: 1rem;
            margin: 0 0 0.75rem 0;
        }

        .data-quality-content ul {
            margin: 0 0 1.25rem 0;
            padding-left: 1.5rem;
            color: var(--color-text-secondary);
        }

        .data-quality-content li {
            margin-bottom: 0.5rem;
            line-height: 1.5;
        }

        .data-quality-content p {
            margin: 0;
            color: var(--color-text-secondary);
            font-size: 0.875rem;
            line-height: 1.6;
        }

        .data-quality-content strong {
            color: var(--color-text);
        }


        /* KPI Cards - Styled to match insight-panel aesthetic */
        .kpi-cards {
            background: var(--color-surface);
            border-radius: var(--radius-lg);
            padding: 1.25rem 1.5rem;
            margin-bottom: 2rem;
            box-shadow: var(--shadow-md);
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 1rem;
        }

        .kpi-card {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.75rem;
            background: rgba(255, 255, 255, 0.03);
            border-radius: var(--radius-md);
            border: 1px solid rgba(255, 255, 255, 0.05);
            text-align: left;
        }

        .kpi-icon {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }

        .kpi-icon svg {
            width: 20px;
            height: 20px;
        }

        .kpi-icon-map {
            background: rgba(138, 43, 226, 0.2);
        }

        .kpi-icon-map svg {
            color: #a855f7;
        }

        .kpi-icon-type {
            background: rgba(0, 191, 255, 0.2);
        }

        .kpi-icon-type svg {
            color: #00bfff;
        }

        .kpi-icon-time {
            background: rgba(240, 160, 64, 0.2);
        }

        .kpi-icon-time svg {
            color: #f0a040;
        }

        .kpi-icon-severity {
            background: rgba(224, 93, 93, 0.2);
        }

        .kpi-icon-severity svg {
            color: #e05d5d;
        }

        .kpi-content {
            flex: 1;
        }

        .kpi-label {
            font-size: 0.75rem;
            color: var(--color-text-secondary);
            text-transform: uppercase;
            letter-spacing: 0.05em;
            margin-bottom: 0.25rem;
        }

        .kpi-value {
            font-size: 1rem;
            font-weight: 600;
            color: var(--color-text);
            line-height: 1.3;
        }

        /* Responsive: 2x2 grid on tablets */
        @media (max-width: 1024px) {
            .kpi-cards {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        /* Responsive: Stack on mobile */
        @media (max-width: 768px) {
            .kpi-cards {
                grid-template-columns: 1fr;
                gap: 0.75rem;
                padding: 1rem;
            }

            .kpi-card {
                padding: 0.625rem;
            }
        }

        /* Dashboard Grid */
        .dashboard-grid {
            display: grid;
            grid-template-columns: 60% 40%;
            gap: 2rem;
            margin-bottom: 3rem;
        }

        @media (max-width: 1200px) {
            .dashboard-grid {
                grid-template-columns: 1fr;
            }
        }

        /* Map Section */
        .map-section {
            position: relative;
            background: var(--color-surface);
            border-radius: var(--radius-xl);
            padding: 1.5rem;
            box-shadow: var(--shadow-md);
            display: flex;
            flex-direction: column;
            height: 600px;
        }

        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .section-header h2 {
            font-family: 'Silkscreen', 'Courier New', monospace;
            font-size: 1.25rem;
            color: #ffffff;
            text-shadow: 0 0 10px rgba(138, 43, 226, 0.4);
        }

        .map-controls {
            display: flex;
            gap: 0.5rem;
        }

        .btn-secondary {
            padding: 0.5rem 1rem;
            border: 1px solid rgba(138, 43, 226, 0.5);
            background: rgba(138, 43, 226, 0.15);
            color: #e0e0ff;
            border-radius: var(--radius-md);
            font-family: 'Silkscreen', 'Courier New', monospace;
            font-size: 0.75rem;
            font-weight: 400;
            cursor: pointer;
            transition: all 0.2s;
        }

        .btn-secondary.active {
            background: rgba(138, 43, 226, 0.4);
            border-color: rgba(138, 43, 226, 0.8);
            color: white;
            box-shadow: 0 0 10px rgba(138, 43, 226, 0.3);
        }

        .btn-secondary:hover {
            background: rgba(138, 43, 226, 0.25);
            border-color: rgba(138, 43, 226, 0.6);
        }

        .map-wrapper {
            position: relative;
            flex: 1;
            min-height: 0;
        }

        .collision-map {
            width: 100%;
            height: 100%;
            border-radius: var(--radius-md);
            overflow: hidden;
        }

        .map-stats-overlay {
            position: absolute;
            top: 12px;
            left: 12px;
            background: rgba(0, 0, 0, 0.8);
            color: #ffffff;
            padding: 6px 12px;
            border-radius: 4px;
            font-size: 0.8rem;
            font-weight: 500;
            z-index: 10;
        }

        /* Map Legend - Dark Theme */
        .map-legend {
            position: absolute;
            bottom: 16px;
            left: 16px;
            background: rgba(26, 26, 26, 0.95);
            padding: 12px 16px;
            border-radius: var(--radius-md);
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 0.75rem;
            z-index: 10;
            max-width: 200px;
        }

        .map-legend h4 {
            margin: 0 0 8px 0;
            font-size: 0.875rem;
            font-weight: 600;
            color: #ffffff;
        }

        .legend-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 4px;
        }

        .legend-item:last-child {
            margin-bottom: 0;
        }

        .legend-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            border: 1px solid rgba(255, 255, 255, 0.2);
            flex-shrink: 0;
        }

        .legend-label {
            color: #e0e0e0;
            font-size: 0.75rem;
            line-height: 1.3;
        }

        .legend-help {
            margin-top: 0.5rem;
            font-size: 0.7rem;
            color: #888;
            line-height: 1.3;
        }

        @media (max-width: 768px) {
            .map-legend {
                bottom: 10px;
                left: 10px;
                font-size: 0.65rem;
                padding: 8px 12px;
            }

            .map-stats-overlay {
                top: 8px;
                left: 8px;
                font-size: 0.7rem;
                padding: 4px 8px;
            }
        }

        /* Charts Section */
        .charts-wrapper {
            background: var(--color-surface);
            border-radius: var(--radius-lg);
            padding: 1.5rem;
            margin-bottom: 3rem;
            box-shadow: var(--shadow-md);
            overflow: hidden;
        }

        .charts-section {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 1rem;
            margin-bottom: 1rem;
        }

        @media (max-width: 1200px) {
            .charts-section {
                grid-template-columns: 1fr;
            }
        }

        .chart-container {
            background: var(--color-bg);
            border-radius: var(--radius-md);
            padding: 1rem;
            box-shadow: var(--shadow-sm);
            height: 260px;
            min-width: 0;
            overflow: hidden;
        }

        .chart-container h3 {
            font-family: 'Silkscreen', 'Courier New', monospace;
            font-size: 1rem;
            color: #ffffff;
            text-shadow: 0 0 8px rgba(138, 43, 226, 0.3);
            margin-bottom: 1rem;
        }

        .chart-container canvas {
            max-height: 180px;
            width: 100% !important;
            max-width: 100%;
        }

        /* Chart Controls - Dark Theme */
        .chart-controls {
            display: grid;
            grid-template-columns: auto auto auto auto;
            gap: 1rem 2rem;
            justify-content: center;
            align-items: center;
            padding: 1rem 1.5rem;
            background: rgba(255, 255, 255, 0.03);
            border-radius: var(--radius-md);
            border-top: 1px solid rgba(255, 255, 255, 0.08);
        }

        .control-group {
            display: contents;
        }

        .control-group label {
            font-family: 'Silkscreen', 'Courier New', monospace;
            font-size: 0.75rem;
            color: var(--color-text-secondary);
            font-weight: 400;
            text-align: right;
            white-space: nowrap;
        }

        .button-group {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .btn-control {
            padding: 0.5rem 1rem;
            font-size: 0.7rem;
            font-family: 'Silkscreen', 'Courier New', monospace;
            background: rgba(0, 191, 255, 0.1);
            color: #e0f0ff;
            border: 1px solid rgba(0, 191, 255, 0.3);
            border-radius: 2rem;
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .btn-control:hover {
            background: rgba(0, 191, 255, 0.15);
            border-color: rgba(0, 191, 255, 0.5);
        }

        .btn-control.active {
            background: rgba(0, 191, 255, 0.25);
            color: #fff;
            border-color: rgba(0, 191, 255, 0.7);
            box-shadow: 0 0 8px rgba(0, 191, 255, 0.3);
        }

        .btn-control.active:hover {
            background: rgba(0, 191, 255, 0.3);
        }

        /* Filter Panel */
        .filter-panel {
            background: var(--color-surface);
            border-radius: var(--radius-lg);
            padding: 1.5rem;
            box-shadow: var(--shadow-md);
            margin-bottom: 3rem;
        }

        .filter-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
        }

        .filter-header h3 {
            font-family: 'Silkscreen', 'Courier New', monospace;
            font-size: 1rem;
            color: #ffffff;
            text-shadow: 0 0 8px rgba(138, 43, 226, 0.3);
        }

        .btn-text {
            background: none;
            border: none;
            color: var(--color-accent-rust);
            cursor: pointer;
            font-weight: 500;
            text-decoration: underline;
        }

        .btn-text:hover {
            opacity: 0.7;
        }

        .filter-group {
            margin-bottom: 1.5rem;
        }

        /* Collapsible filter groups using <details> */
        .filter-collapsible {
            border: none;
        }

        .filter-collapsible summary {
            display: block;
            font-weight: 500;
            margin-bottom: 0.5rem;
            color: var(--color-text);
            cursor: pointer;
            list-style: none;
            user-select: none;
        }

        .filter-collapsible summary::-webkit-details-marker {
            display: none;
        }

        .filter-collapsible summary::after {
            content: '▼';
            float: right;
            font-size: 0.75rem;
            color: var(--color-text-secondary);
            transition: transform 0.2s;
        }

        .filter-collapsible[open] summary::after {
            transform: rotate(180deg);
        }

        /* On mobile, collapse filters by default */
        @media (max-width: 768px) {
            .filter-collapsible:not([open]) > :not(summary) {
                display: none;
            }

            .filter-collapsible summary {
                padding: 0.75rem 0;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            }
        }

        .filter-group label {
            display: block;
            font-weight: 500;
            margin-bottom: 0.5rem;
            color: var(--color-text);
        }

        .form-control {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: var(--radius-md);
            font-size: 1rem;
            background: rgba(255, 255, 255, 0.05);
            color: var(--color-text);
        }

        .form-control:focus {
            outline: none;
            border-color: var(--color-accent-rust);
            background: rgba(255, 255, 255, 0.08);
        }

        /* Date Range Slider */
        .date-range-slider {
            padding: 1rem;
            margin: 0 -0.5rem;
            background: rgba(0, 191, 255, 0.05);
            border-radius: var(--radius-md);
            box-shadow:
                0 0 15px rgba(0, 191, 255, 0.1),
                inset 0 0 20px rgba(0, 191, 255, 0.03);
            border: 1px solid rgba(0, 191, 255, 0.15);
        }

        .date-range-labels {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.75rem;
            font-family: 'Silkscreen', 'Courier New', monospace;
            font-size: 0.75rem;
            color: #e0f0ff;
        }

        .slider-container {
            position: relative;
            height: 20px;
        }

        .slider-track {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 100%;
            height: 4px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 2px;
        }

        .slider-range {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            height: 4px;
            background: rgba(0, 191, 255, 0.5);
            border-radius: 2px;
            box-shadow: 0 0 8px rgba(0, 191, 255, 0.3);
        }

        .slider-container input[type="range"] {
            position: absolute;
            top: 0;
            width: 100%;
            height: 20px;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            pointer-events: none;
            margin: 0;
        }

        .slider-container input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: #00bfff;
            border-radius: 50%;
            cursor: pointer;
            pointer-events: auto;
            box-shadow: 0 0 10px rgba(0, 191, 255, 0.5);
            border: 2px solid #fff;
        }

        .slider-container input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: #00bfff;
            border-radius: 50%;
            cursor: pointer;
            pointer-events: auto;
            box-shadow: 0 0 10px rgba(0, 191, 255, 0.5);
            border: 2px solid #fff;
        }

        .slider-container input[type="range"]:focus {
            outline: none;
        }

        .slider-container input[type="range"]:focus::-webkit-slider-thumb {
            box-shadow: 0 0 15px rgba(0, 191, 255, 0.8);
        }

        .chip-group {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
        }

        .chip {
            padding: 0.5rem 1rem;
            border: 1px solid rgba(0, 191, 255, 0.3);
            background: rgba(0, 191, 255, 0.1);
            color: #e0f0ff;
            border-radius: 2rem;
            font-family: 'Silkscreen', 'Courier New', monospace;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .chip:hover {
            border-color: rgba(0, 191, 255, 0.5);
            background: rgba(0, 191, 255, 0.15);
        }

        .chip.active {
            border-color: rgba(0, 191, 255, 0.7);
            background: rgba(0, 191, 255, 0.25);
            color: white;
            box-shadow: 0 0 8px rgba(0, 191, 255, 0.3);
        }

        .checkbox-group {
            display: flex;
            gap: 1rem;
        }

        .checkbox-group label {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            font-weight: normal;
            cursor: pointer;
        }

        .checkbox-group input[type="checkbox"] {
            appearance: none;
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            border: 1px solid rgba(0, 191, 255, 0.4);
            border-radius: 3px;
            background: rgba(0, 191, 255, 0.1);
            cursor: pointer;
            position: relative;
            flex-shrink: 0;
        }

        .checkbox-group input[type="checkbox"]:checked {
            background: rgba(0, 191, 255, 0.3);
            border-color: rgba(0, 191, 255, 0.7);
        }

        .checkbox-group input[type="checkbox"]:checked::after {
            content: '';
            position: absolute;
            width: 10px;
            height: 10px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #00ffff;
            border-radius: 2px;
        }

        .checkbox-group input[type="checkbox"]:hover {
            border-color: rgba(0, 191, 255, 0.6);
        }

        /* Detail Panel */
        .detail-panel {
            position: fixed;
            right: 0;
            top: 0;
            width: 600px;
            height: 100vh;
            background: rgba(15, 18, 25, 0.98);
            backdrop-filter: blur(10px);
            box-shadow:
                -4px 0 20px rgba(0, 0, 0, 0.4),
                -1px 0 0 rgba(0, 191, 255, 0.15);
            padding: 2rem;
            overflow-y: auto;
            z-index: 1000;
            animation: slideIn 0.3s ease-out;
        }

        .detail-panel .drag-handle {
            display: none;
        }

        @keyframes slideIn {
            from { transform: translateX(100%); }
            to { transform: translateX(0); }
        }

        .detail-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            border-bottom: 1px solid rgba(0, 191, 255, 0.2);
            padding-bottom: 1rem;
        }

        .detail-header h3 {
            font-family: 'Silkscreen', 'Courier New', monospace;
            font-size: 1rem;
            color: #e0f0ff;
            font-weight: 400;
            letter-spacing: 0.5px;
        }

        .btn-icon {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: rgba(255, 255, 255, 0.5);
            transition: color 0.2s ease;
        }

        .btn-icon:hover {
            color: rgba(0, 191, 255, 0.9);
        }

        .detail-row {
            display: grid;
            grid-template-columns: 140px 1fr;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
            padding-bottom: 0.75rem;
            border-bottom: 1px solid rgba(0, 191, 255, 0.1);
        }

        .detail-label {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.75rem;
            font-weight: 400;
            color: rgba(255, 255, 255, 0.6);
        }

        .detail-value {
            font-family: 'IBM Plex Mono', monospace;
            font-size: 0.8rem;
            color: #e0f0ff;
        }

        /* Mobile Responsive */
        @media (max-width: 768px) {
            .dashboard-container {
                padding: 60px 1rem 2rem;
            }

            .kpi-cards {
                grid-template-columns: repeat(2, 1fr);
            }

            .map-wrapper {
                min-height: 400px;
            }

            .chart-container {
                height: 250px;
            }

            /* Mobile bottom sheet for detail panel */
            .detail-panel {
                width: 100%;
                top: auto;
                bottom: 0;
                left: 0;
                right: 0;
                height: auto;
                max-height: 70vh;
                border-radius: 1rem 1rem 0 0;
                animation: slideUp 0.3s ease-out;
                padding: 1rem 1.5rem 2rem;
            }

            @keyframes slideUp {
                from { transform: translateY(100%); }
                to { transform: translateY(0); }
            }

            .detail-panel .detail-header {
                flex-direction: column;
                align-items: stretch;
            }

            .detail-panel .drag-handle {
                display: block;
                width: 40px;
                height: 4px;
                background: rgba(255, 255, 255, 0.3);
                border-radius: 2px;
                margin: 0 auto 1rem;
            }

            .detail-grid {
                grid-template-columns: 1fr;
            }

            .filter-panel {
                padding: 1rem;
            }

            /* Stack and center button groups on mobile */
            .map-controls {
                flex-direction: column;
                align-items: center;
                gap: 0.5rem;
            }

            .map-controls .btn-secondary {
                width: auto;
                min-width: 150px;
            }

            .section-header {
                flex-direction: column;
                align-items: center;
                gap: 1rem;
            }

            .button-group {
                flex-direction: column;
                align-items: center;
                width: 100%;
            }

            .button-group label {
                text-align: center;
                margin-bottom: 0.5rem;
            }

            .button-group .btn-control {
                width: auto;
                min-width: 140px;
            }

            .chart-controls {
                grid-template-columns: 1fr;
                gap: 1rem;
                justify-items: center;
            }

            .chart-controls .control-group {
                width: 100%;
                display: flex;
                justify-content: center;
            }
        }

        /* ===== Hover Tooltip Styling ===== */

        /* MapLibre popup container override */
        .maplibregl-popup.collision-tooltip .maplibregl-popup-content {
            padding: 0;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            min-width: 250px;
            max-width: 300px;
            font-size: 13px;
            line-height: 1.4;
        }

        .maplibregl-popup.collision-tooltip .maplibregl-popup-tip {
            border-top-color: #1a1a1a;
        }

        /* Tooltip header with area name and severity badge */
        .tooltip-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            background: #1a1a1a;
            border-radius: 8px 8px 0 0;
            border-bottom: 1px solid #333;
        }

        .tooltip-title {
            font-weight: 600;
            font-size: 14px;
            color: #fff;
            flex: 1;
        }

        .tooltip-severity {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            color: #fff;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Tooltip body with collision details */
        .tooltip-body {
            padding: 10px 12px;
            background: #2a2a2a;
        }

        .tooltip-row {
            display: flex;
            margin-bottom: 6px;
        }

        .tooltip-row:last-child {
            margin-bottom: 0;
        }

        .tooltip-label {
            flex: 0 0 75px;
            font-weight: 500;
            color: #999;
        }

        .tooltip-value {
            flex: 1;
            color: #fff;
            word-break: break-word;
        }

        /* Special circumstance badges */
        .tooltip-badge {
            display: inline-block;
            padding: 3px 8px;
            margin-top: 8px;
            margin-right: 6px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .tooltip-badge.hit-run {
            background: var(--color-pedestrian);
            color: #fff;
        }

        .tooltip-badge.dui {
            background: var(--color-motorcycle);
            color: #1a1a1a;
        }

        .badge-warn {
            display: inline-block;
            padding: 2px 6px;
            background: var(--color-pedestrian);
            color: #fff;
            border-radius: 3px;
            font-size: 10px;
            font-weight: 600;
            text-transform: uppercase;
        }

        .tooltip-badge.severity-property_damage { background: var(--color-severity-property); color: #fff; }
        .tooltip-badge.severity-minor_injury { background: var(--color-severity-minor); color: #1a1a1a; }
        .tooltip-badge.severity-severe_injury { background: var(--color-severity-severe); color: #fff; }
        .tooltip-badge.severity-fatal { background: var(--color-severity-fatal); color: #fff; }
        .tooltip-badge.severity-unknown { background: var(--color-severity-unknown); color: #fff; }

        /* Detail panel sections */
        .detail-section {
            margin-bottom: 1.5rem;
            padding-bottom: 1.5rem;
            border-bottom: 1px solid rgba(0, 191, 255, 0.15);
        }

        .detail-section:last-child {
            border-bottom: none;
            margin-bottom: 0;
            padding-bottom: 0;
        }

        .detail-section-title {
            font-family: 'Silkscreen', 'Courier New', monospace;
            font-size: 0.8rem;
            font-weight: 400;
            color: rgba(0, 191, 255, 0.8);
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
            letter-spacing: 0.5px;
        }

        .detail-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 0.75rem;
        }

        .detail-row-full {
            grid-column: 1 / -1;
        }

        .text-danger {
            color: var(--color-pedestrian) !important;
            font-weight: 600;
        }

        /* Footer hint */
        .tooltip-footer {
            padding: 8px 12px;
            background: #222;
            border-top: 1px solid #333;
            text-align: center;
        }

        .tooltip-hint {
            font-size: 11px;
            color: #777;
            font-style: italic;
        }

        /* Debug section (collapsible) */
        .tooltip-debug {
            background: #1a1a1a;
            border-top: 1px solid #333;
            border-radius: 0 0 8px 8px;
        }

        .tooltip-debug details {
            padding: 8px 12px;
        }

        .tooltip-debug summary {
            font-size: 11px;
            color: #888;
            cursor: pointer;
            user-select: none;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .tooltip-debug summary:hover {
            color: #aaa;
        }

        .debug-content {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid #2a2a2a;
            font-size: 11px;
            font-family: 'Courier New', monospace;
            color: #aaa;
        }

        .debug-content div {
            margin-bottom: 4px;
        }

        /* ===== Data Table Styling ===== */

        .table-section {
            display: flex;
            flex-direction: column;
            background: #2a2a2a;
            border-radius: var(--radius-xl);  /* Match map-section border-radius */
            padding: 1.5rem;
            height: 600px;
            overflow: hidden;  /* Ensure table corners are clipped */
        }

        @media (max-width: 1200px) {
            .table-section {
                max-height: 400px;
            }
        }

        .table-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .table-header h2 {
            font-size: 1.5rem;
            margin: 0 0 0.25rem 0;
            color: #ffffff;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.3);
        }

        .table-count {
            font-size: 0.875rem;
            color: #b3b3b3;
            font-weight: 400;
        }

        .table-controls {
            display: flex;
            gap: 0.5rem;
        }

        .table-container {
            overflow-x: auto;
            margin-top: 1rem;
        }

        .table-container-fixed {
            flex: 1;
            overflow-y: auto;
            overflow-x: auto;
            margin-top: 1rem;
        }

        .collisions-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.875rem;
        }

        .collisions-table thead {
            background: #1a1a1a;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .collisions-table th {
            padding: 0.75rem;
            text-align: left;
            font-weight: 600;
            color: #fff;
            border-bottom: 2px solid #444;
            cursor: pointer;
            user-select: none;
        }

        .collisions-table th:hover {
            background: #252525;
        }

        .sort-icon {
            font-size: 0.75rem;
            color: #666;
            margin-left: 0.25rem;
        }

        .collisions-table th.sorted-asc .sort-icon {
            color: #4CAF50;
        }

        .collisions-table th.sorted-desc .sort-icon {
            color: #4CAF50;
        }

        .collisions-table tbody tr {
            border-bottom: 1px solid #333;
            transition: background-color 0.15s;
            cursor: pointer;
        }

        .collisions-table tbody tr:hover {
            background: #333;
        }

        .collisions-table tbody tr.highlighted {
            background-color: rgba(255, 154, 108, 0.3) !important;
            border-left: 3px solid var(--color-accent-rust);
        }

        .collisions-table td {
            padding: 0.75rem;
            color: #ddd;
        }

        .severity-badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
            color: #fff;
            text-transform: uppercase;
        }

        .severity-property_damage { background: var(--color-severity-property); }
        .severity-minor_injury { background: var(--color-severity-minor); color: #1a1a1a; }
        .severity-severe_injury { background: var(--color-severity-severe); }
        .severity-fatal { background: var(--color-severity-fatal); }
        .severity-unknown { background: var(--color-severity-unknown); }

        #tableLoadMore {
            padding: 1rem;
            text-align: center;
            color: #999;
            font-size: 0.875rem;
            border-top: 1px solid #333;
            margin-top: 0.5rem;
        }

        @media (max-width: 768px) {
            .table-header {
                flex-direction: column;
                align-items: flex-start;
                gap: 1rem;
            }

            .collisions-table {
                font-size: 0.75rem;
            }

            .collisions-table th,
            .collisions-table td {
                padding: 0.5rem;
            }
        }
    </style>
</head>
<body>
    <!-- Dashboard Container -->
    <div class="dashboard-container">
        <!-- Dashboard Header -->
        <header class="dashboard-header">
            <h1>LA Traffic Collisions (2010-2025)</h1>
            <p class="subtitle">620,659 collision records from LAPD &bull; <a id="showDataNotes">See data notes</a></p>
        </header>

        <!-- KPI Cards Section -->
        <section class="kpi-cards">
            <div class="kpi-card">
                <span class="kpi-icon kpi-icon-map" aria-hidden="true">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path>
                        <circle cx="12" cy="10" r="3"></circle>
                    </svg>
                </span>
                <div class="kpi-content">
                    <div class="kpi-label">Area in View</div>
                    <div class="kpi-value" id="topArea">-</div>
                </div>
            </div>
            <div class="kpi-card">
                <span class="kpi-icon kpi-icon-type" aria-hidden="true">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="1" y="3" width="15" height="13"></rect>
                        <polygon points="16 8 20 8 23 11 23 16 16 16 16 8"></polygon>
                        <circle cx="5.5" cy="18.5" r="2.5"></circle>
                        <circle cx="18.5" cy="18.5" r="2.5"></circle>
                    </svg>
                </span>
                <div class="kpi-content">
                    <div class="kpi-label">Collision Type</div>
                    <div class="kpi-value" id="topCollisionType">-</div>
                </div>
            </div>
            <div class="kpi-card">
                <span class="kpi-icon kpi-icon-time" aria-hidden="true">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <circle cx="12" cy="12" r="10"></circle>
                        <polyline points="12 6 12 12 16 14"></polyline>
                    </svg>
                </span>
                <div class="kpi-content">
                    <div class="kpi-label">Peak Hour</div>
                    <div class="kpi-value" id="viewportPeakHour">-</div>
                </div>
            </div>
            <div class="kpi-card">
                <span class="kpi-icon kpi-icon-severity" aria-hidden="true">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path>
                        <line x1="12" y1="9" x2="12" y2="13"></line>
                        <line x1="12" y1="17" x2="12.01" y2="17"></line>
                    </svg>
                </span>
                <div class="kpi-content">
                    <div class="kpi-label">Severity</div>
                    <div class="kpi-value" id="topSeverity">-</div>
                </div>
            </div>
        </section>


        <!-- Main Dashboard Grid -->
        <div class="dashboard-grid">
            <!-- Left: Map -->
            <section class="map-section">
                <div class="section-header">
                    <h2>Collision Map</h2>
                    <div class="map-controls" role="group" aria-label="Map color scheme">
                        <button id="colorByType" class="btn-secondary active" aria-pressed="true">By Collision Type</button>
                        <button id="colorByTime" class="btn-secondary" aria-pressed="false">By Time of Day</button>
                    </div>
                </div>
                <div class="map-wrapper">
                    <div id="map" class="collision-map" role="application" aria-label="Interactive collision map"></div>
                    <div class="map-stats-overlay">
                        <span id="visibleCollisions" aria-live="polite" aria-atomic="true">0</span> collisions in view
                        <span id="samplingIndicator" style="display:none;"></span>
                    </div>
                    <div class="map-legend" id="mapLegend">
                        <!-- Populated by JavaScript -->
                    </div>
                </div>
            </section>

            <!-- Right: Data Table (40%) - Always Visible -->
            <section class="table-section">
                <div class="section-header">
                    <div>
                        <h2>Collisions in View</h2>
                        <span id="tableCount" class="table-count">0 collisions</span>
                    </div>
                </div>
                <div class="table-container-fixed">
                    <table id="collisionsTable" class="collisions-table">
                        <thead>
                            <tr>
                                <th data-sort="date_occ">Date <span class="sort-icon">⇅</span></th>
                                <th data-sort="time_occ_minutes">Time <span class="sort-icon">⇅</span></th>
                                <th data-sort="severity">Severity <span class="sort-icon">⇅</span></th>
                                <th data-sort="collision_type">Type <span class="sort-icon">⇅</span></th>
                                <th data-sort="address">Location <span class="sort-icon">⇅</span></th>
                            </tr>
                        </thead>
                        <tbody id="tableBody">
                            <!-- Populated by JavaScript -->
                        </tbody>
                    </table>
                </div>
                <div id="tableLoadMore" style="display: none; padding: 0.5rem; text-align: center; color: #999; font-size: 0.875rem;"></div>
            </section>
        </div>

        <!-- Charts Section with Controls -->
        <section class="charts-wrapper">
            <div class="charts-section">
                <div class="chart-container">
                    <h3>Collisions by Hour</h3>
                    <canvas id="hourChart"></canvas>
                </div>
                <div class="chart-container">
                    <h3>Collisions by Day of Week</h3>
                    <canvas id="dowChart"></canvas>
                </div>
                <div class="chart-container">
                    <h3>Trend Over Time</h3>
                    <canvas id="yearChart"></canvas>
                </div>
            </div>

            <!-- Chart Controls -->
            <div class="chart-controls">
                <div class="control-group">
                    <div class="button-group">
                        <label>Data Scope:</label>
                        <button class="btn-control active" data-scope="viewport">
                            Viewport Only
                        </button>
                        <button class="btn-control" data-scope="all">
                            All Filtered
                        </button>
                    </div>
                </div>

                <div class="control-group">
                    <div class="button-group">
                        <label>Display Mode:</label>
                        <button class="btn-control active" data-mode="stacked">
                            Stacked
                        </button>
                        <button class="btn-control" data-mode="grouped">
                            Grouped
                        </button>
                        <button class="btn-control" data-mode="total">
                            Total Only
                        </button>
                    </div>
                </div>
            </div>
        </section>

        <!-- Filter Panel -->
        <aside id="filterPanel" class="filter-panel" role="region" aria-label="Filter controls">
            <div class="filter-header">
                <h3>Filters</h3>
                <button id="resetFilters" class="btn-control">Reset All</button>
            </div>

            <!-- Time of Day Filter -->
            <details class="filter-group filter-collapsible" open>
                <summary>Time of Day</summary>
                <div class="chip-group" id="timeFilters">
                    <button class="chip active" data-bucket="AM_PEAK" role="checkbox" aria-checked="true">AM Peak</button>
                    <button class="chip active" data-bucket="MIDDAY" role="checkbox" aria-checked="true">Midday</button>
                    <button class="chip active" data-bucket="PM_PEAK" role="checkbox" aria-checked="true">PM Peak</button>
                    <button class="chip active" data-bucket="EVENING" role="checkbox" aria-checked="true">Evening</button>
                    <button class="chip active" data-bucket="LATE_NIGHT" role="checkbox" aria-checked="true">Late Night</button>
                    <button class="chip active" data-bucket="EARLY_MORNING" role="checkbox" aria-checked="true">Early AM</button>
                </div>
            </details>

            <!-- Day of Week Filter -->
            <details class="filter-group filter-collapsible" open>
                <summary>Days of Week</summary>
                <div class="chip-group" id="dayFilters">
                    <button class="chip active" data-day="weekday" role="checkbox" aria-checked="true">Weekdays</button>
                    <button class="chip active" data-day="weekend" role="checkbox" aria-checked="true">Weekends</button>
                </div>
            </details>

            <!-- Collision Type Filter -->
            <details class="filter-group filter-collapsible" open>
                <summary>Collision Type</summary>
                <div class="chip-group" id="collisionTypeFilters">
                    <button class="chip active" data-type="vehicle-to-vehicle" role="checkbox" aria-checked="true">Vehicle-Vehicle</button>
                    <button class="chip active" data-type="vehicle-pedestrian" role="checkbox" aria-checked="true">Pedestrian</button>
                    <button class="chip active" data-type="vehicle-motorcycle" role="checkbox" aria-checked="true">Motorcycle</button>
                    <button class="chip active" data-type="vehicle-bicycle" role="checkbox" aria-checked="true">Bicycle</button>
                    <button class="chip active" data-type="other" role="checkbox" aria-checked="true">Other</button>
                </div>
            </details>

            <!-- Severity Filter -->
            <details class="filter-group filter-collapsible" open>
                <summary>Severity Level</summary>
                <div class="chip-group" id="severityFilters">
                    <button class="chip active" data-severity="property_damage" role="checkbox" aria-checked="true">Property Damage</button>
                    <button class="chip active" data-severity="minor_injury" role="checkbox" aria-checked="true">Minor Injury</button>
                    <button class="chip active" data-severity="severe_injury" role="checkbox" aria-checked="true">Severe Injury</button>
                    <button class="chip active" data-severity="unknown" role="checkbox" aria-checked="true">Unknown</button>
                </div>
            </details>

            <!-- Special Circumstances -->
            <details class="filter-group filter-collapsible" open>
                <summary>Special Circumstances</summary>
                <div class="chip-group" id="specialFilters">
                    <button class="chip" data-special="hit_and_run" role="checkbox" aria-checked="false">Hit & Run</button>
                    <button class="chip" data-special="dui" role="checkbox" aria-checked="false">DUI-Related</button>
                </div>
            </details>

            <!-- Date Range Filter -->
            <details class="filter-group filter-collapsible" open>
                <summary>Date Range</summary>
                <div class="date-range-slider">
                    <div class="date-range-labels">
                        <span id="dateStartLabel">Jan 2010</span>
                        <span id="dateEndLabel">Mar 2025</span>
                    </div>
                    <div class="slider-container">
                        <div class="slider-track"></div>
                        <div class="slider-range" id="sliderRange"></div>
                        <input type="range" id="dateStartSlider" min="0" max="182" value="0" aria-label="Start date">
                        <input type="range" id="dateEndSlider" min="0" max="182" value="182" aria-label="End date">
                    </div>
                </div>
            </details>
        </aside>

        <!-- Data Quality Banner -->
        <aside class="data-quality-banner" id="dataQualityBanner">
            <div class="data-quality-header" id="dataQualityHeader">
                <span class="data-quality-title">
                    <span class="data-quality-icon">&#9888;</span>
                    Data Quality &amp; Methodology Notes
                </span>
                <button class="data-quality-toggle" aria-label="Toggle data notes">&#9660;</button>
            </div>
            <div class="data-quality-content">
                <h4>Severity Classification</h4>
                <ul>
                    <li><strong>No fatality data available:</strong> LAPD MO codes do not reliably indicate fatal collisions. Records are classified as severe injury, minor injury, property damage, or unknown.</li>
                    <li><strong>Severity categories:</strong> Based on injury codes (40xx series) - "Severe" includes incapacitating/visible injuries; "Minor" includes complaint of pain.</li>
                    <li><strong>~37% marked "Unknown":</strong> Records without clear injury indicator codes in their MO data.</li>
                </ul>

                <h4>Data Coverage</h4>
                <ul>
                    <li><strong>Date range:</strong> January 2010 - March 2025 (latest available)</li>
                    <li><strong>2020-2021 drop:</strong> Sharp decline in reported collisions coincides with COVID-19 pandemic reduced traffic.</li>
                    <li><strong>2021+ partial data:</strong> Years 2022-2025 show reduced record counts; may reflect ongoing data collection delays.</li>
                </ul>

                <h4>Collision Types</h4>
                <ul>
                    <li><strong>Bicycle collisions (43%):</strong> Higher than national average (~2%) - this reflects LAPD's classification methodology, not actual collision distribution.</li>
                    <li><strong>Classification method:</strong> Based on MO codes indicating vehicle/pedestrian/bicycle/motorcycle involvement.</li>
                </ul>

                <p><strong>Source:</strong> LAPD Traffic Collision Data via LA Open Data Portal. Last updated March 2025.</p>
            </div>
        </aside>

    </div>

    <!-- Collision Detail Panel (outside dashboard-container for proper fixed positioning) -->
    <aside id="detailPanel" class="detail-panel" style="display:none;" role="dialog" aria-label="Collision Details">
        <div class="drag-handle" aria-hidden="true"></div>
        <div class="detail-header">
            <h3>Collision Details</h3>
            <button id="closeDetail" class="btn-icon" aria-label="Close details">&times;</button>
        </div>
        <div class="detail-content" id="detailContent"></div>
    </aside>

    <!-- JavaScript -->
    <script>
        /**
         * LRU (Least Recently Used) Cache for tile management
         * Prevents unbounded memory growth during extended panning
         */
        class LRUCache {
            constructor(maxSize = 100) {
                this.maxSize = maxSize;
                this.cache = new Map();
            }

            has(key) {
                return this.cache.has(key);
            }

            get(key) {
                if (!this.cache.has(key)) return undefined;

                // Move to end (most recently used)
                const value = this.cache.get(key);
                this.cache.delete(key);
                this.cache.set(key, value);
                return value;
            }

            set(key, value) {
                // If key exists, delete it first to update position
                if (this.cache.has(key)) {
                    this.cache.delete(key);
                }

                // Evict oldest entries if at capacity
                while (this.cache.size >= this.maxSize) {
                    const oldestKey = this.cache.keys().next().value;
                    this.cache.delete(oldestKey);
                }

                this.cache.set(key, value);
            }

            values() {
                return this.cache.values();
            }

            size() {
                return this.cache.size;
            }

            clear() {
                this.cache.clear();
            }
        }

        /**
         * Dashboard configuration constants
         * Centralized to avoid magic numbers throughout the codebase
         */
        const CONFIG = {
            // Tile system
            TILE_SIZE: 0.02,                    // Degrees (~2km x 2km tiles)
            MAX_TILE_CACHE: 100,                // Max tiles in LRU cache (~200MB)

            // Rendering
            MAX_POINTS_TO_RENDER: 50000,        // Sample limit for performance
            DEBOUNCE_DELAY: 200,                // ms for map updates
            TABLE_DEBOUNCE_DELAY: 500,          // ms for table updates

            // Network
            MAX_RETRIES: 3,                     // Tile fetch retry attempts
            RETRY_BASE_DELAY: 500,              // ms base for exponential backoff

            // Map settings
            DEFAULT_CENTER: [-118.4, 34.05],    // Downtown LA
            DEFAULT_ZOOM: 10,
            MAX_ZOOM: 18,

            // Jitter (for overlapping points)
            JITTER_RADIUS: 0.0001,              // ~11 meters in degrees at LA latitude

            // Colors - unified muted palette for dark theme
            COLORS: {
                collisionType: {
                    'vehicle-to-vehicle': '#4a90d9',
                    'vehicle-pedestrian': '#e05d5d',
                    'vehicle-motorcycle': '#f0a040',
                    'vehicle-bicycle': '#50b080',
                    'other': '#8090a0'
                },
                severity: {
                    'property_damage': '#6b7c8d',
                    'minor_injury': '#f4a940',
                    'severe_injury': '#e05d5d',
                    'unknown': '#8090a0'
                }
            },

            // Default filter state
            DEFAULT_FILTERS: {
                dateStart: null,
                dateEnd: null,
                timeBuckets: ['AM_PEAK', 'MIDDAY', 'PM_PEAK', 'EVENING', 'LATE_NIGHT', 'EARLY_MORNING'],
                weekday: true,
                weekend: true,
                collisionTypes: ['vehicle-to-vehicle', 'vehicle-pedestrian', 'vehicle-motorcycle', 'vehicle-bicycle', 'other'],
                severityLevels: ['property_damage', 'minor_injury', 'severe_injury', 'unknown'],
                showHitAndRun: false,
                showDUI: false
            },

            // Date slider configuration
            DATE_SLIDER: {
                startYear: 2010,
                startMonth: 1,   // January
                endYear: 2025,
                endMonth: 3,     // March
                totalMonths: 183 // (2025-2010)*12 + 3 = 183 months, index 0-182
            }
        };

        class LACollisionDashboard {
            constructor() {
                // State
                this.overview = null;
                this.manifest = null;
                this.loadedTiles = new LRUCache(CONFIG.MAX_TILE_CACHE);
                this.spatialIndex = null;
                this.activeColorScheme = 'collision_type';
                this.activeFilters = { ...CONFIG.DEFAULT_FILTERS };
                this.map = null;
                this.selectedCollisionId = null;
                this.charts = {};
                this.chartDataScope = 'viewport';
                this.chartDisplayMode = 'stacked';

                this.init();
            }

            async init() {
                try {
                    await this.loadOverview();
                    this.initMap();
                    this.initCharts();
                    this.initChartControls();
                    // KPIs now viewport-based, will update when map loads
                    this.updateChartsFromOverview();
                    this.attachEventListeners();
                    this.setupMobileNav();
                } catch (error) {
                    console.error('Initialization error:', error);
                }
            }

            async loadOverview() {
                const [overview, manifest] = await Promise.all([
                    fetch('../assets/collisions/overview.json').then(r => r.json()),
                    fetch('../assets/collisions/manifest.json').then(r => r.json())
                ]);

                this.overview = overview;
                this.manifest = manifest;

                // Initialize RBush with tile bounding boxes
                this.spatialIndex = new RBush();
                this.spatialIndex.load(manifest.tiles.map(tile => ({
                    minX: tile.bounds.west,
                    minY: tile.bounds.south,
                    maxX: tile.bounds.east,
                    maxY: tile.bounds.north,
                    tile: tile.filename
                })));
            }

            // Convert month index (0-182) to date string "YYYY-MM-01"
            monthIndexToDate(index) {
                const year = CONFIG.DATE_SLIDER.startYear + Math.floor(index / 12);
                const month = (index % 12) + 1;
                return `${year}-${String(month).padStart(2, '0')}-01`;
            }

            // Convert month index to display label "Mon YYYY"
            monthIndexToLabel(index) {
                const months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                                'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
                const year = CONFIG.DATE_SLIDER.startYear + Math.floor(index / 12);
                const month = index % 12;
                return `${months[month]} ${year}`;
            }

            // Update slider range highlight bar position
            updateSliderRange() {
                const startSlider = document.getElementById('dateStartSlider');
                const endSlider = document.getElementById('dateEndSlider');
                const range = document.getElementById('sliderRange');
                const max = parseInt(startSlider.max);
                const startPercent = (parseInt(startSlider.value) / max) * 100;
                const endPercent = (parseInt(endSlider.value) / max) * 100;
                range.style.left = startPercent + '%';
                range.style.width = (endPercent - startPercent) + '%';
            }

            initMap() {
                this.map = new maplibregl.Map({
                    container: 'map',
                    style: {
                        version: 8,
                        sources: {
                            'osm': {
                                type: 'raster',
                                tiles: ['https://a.tile.openstreetmap.org/{z}/{x}/{y}.png'],
                                tileSize: 256,
                                attribution: '&copy; OpenStreetMap contributors'
                            }
                        },
                        layers: [{
                            id: 'osm',
                            type: 'raster',
                            source: 'osm'
                        }]
                    },
                    center: CONFIG.DEFAULT_CENTER,
                    zoom: CONFIG.DEFAULT_ZOOM,
                    maxZoom: CONFIG.MAX_ZOOM
                });

                this.map.on('load', () => {
                    this.map.addSource('collisions', {
                        type: 'geojson',
                        data: { type: 'FeatureCollection', features: [] },
                        generateId: true  // Auto-generate IDs for setFeatureState
                    });

                    // Helper function to create collision type heatmap with wide color range
                    const createCollisionHeatmap = (collisionType, colorLight, colorBright, colorIntense) => ({
                        id: `collisions-heatmap-${collisionType}`,
                        type: 'heatmap',
                        source: 'collisions',
                        filter: ['==', ['get', 'collision_type'], collisionType],
                        layout: {
                            visibility: 'visible'
                        },
                        paint: {
                            // Higher intensity for better heat spread
                            'heatmap-intensity': [
                                'interpolate', ['linear'], ['zoom'],
                                9, 2.0,
                                12, 4.0
                            ],

                            // Moderate radius for detail
                            'heatmap-radius': [
                                'interpolate', ['linear'], ['zoom'],
                                9, 22,
                                10, 18,
                                11, 14,
                                12, 10
                            ],

                            // Weight based on density - higher for better visibility
                            'heatmap-weight': [
                                'interpolate', ['linear'],
                                ['coalesce', ['get', '_density'], 1],
                                1, 0.3,
                                5, 0.6,
                                10, 0.85,
                                20, 1.0
                            ],

                            // Wide color range: transparent → light → bright → intense
                            // Only most concentrated areas show intense bright color
                            'heatmap-color': [
                                'interpolate', ['linear'], ['heatmap-density'],
                                0.0, 'rgba(0, 0, 0, 0)',        // Transparent
                                0.1, colorLight,                 // Very faint (barely visible)
                                0.3, colorLight,                 // Light (low density)
                                0.5, colorBright,                // Bright (medium density)
                                0.75, colorBright,               // Bright (high density)
                                0.9, colorIntense,               // Very bright (very high)
                                1.0, colorIntense                // Intense (maximum concentration)
                            ],

                            // Progressive opacity - only bright areas very visible
                            // Gradual opacity fade (smooth transition instead of abrupt at zoom 13)
                            'heatmap-opacity': [
                                'interpolate', ['linear'], ['zoom'],
                                9, 0.75,   // Full visibility at low zoom
                                11, 0.6,
                                12, 0.45,
                                13, 0.25,  // Still visible, fading
                                14, 0.1,   // Nearly transparent
                                15, 0      // Fully transparent, scatter plot takes over
                            ]
                        }
                    });

                    // Add 5 collision-type heatmaps with wide color ranges
                    // Vehicle-Vehicle: Light blue → Bright blue → Electric blue
                    this.map.addLayer(createCollisionHeatmap(
                        'vehicle-to-vehicle',
                        'rgba(135, 206, 250, 0.15)',  // Light sky blue
                        'rgba(30, 144, 255, 0.6)',    // Dodger blue
                        'rgba(0, 191, 255, 1.0)'      // Electric deep sky blue
                    ));

                    // Vehicle-Pedestrian: Light red → Bright red → Electric red
                    this.map.addLayer(createCollisionHeatmap(
                        'vehicle-pedestrian',
                        'rgba(255, 160, 160, 0.15)',  // Light coral
                        'rgba(255, 50, 50, 0.6)',     // Bright red
                        'rgba(255, 0, 0, 1.0)'        // Pure red
                    ));

                    // Vehicle-Motorcycle: Light orange → Bright orange → Electric orange
                    this.map.addLayer(createCollisionHeatmap(
                        'vehicle-motorcycle',
                        'rgba(255, 200, 120, 0.15)',  // Light peach
                        'rgba(255, 140, 0, 0.6)',     // Dark orange
                        'rgba(255, 100, 0, 1.0)'      // Bright orange-red
                    ));

                    // Vehicle-Bicycle: Light green → Bright green → Electric green
                    this.map.addLayer(createCollisionHeatmap(
                        'vehicle-bicycle',
                        'rgba(144, 238, 144, 0.15)',  // Light green
                        'rgba(50, 205, 50, 0.6)',     // Lime green
                        'rgba(0, 255, 0, 1.0)'        // Pure green
                    ));

                    // Other: Light gray → Medium gray → Bright white
                    this.map.addLayer(createCollisionHeatmap(
                        'other',
                        'rgba(200, 200, 200, 0.15)',  // Light gray
                        'rgba(169, 169, 169, 0.6)',   // Dark gray
                        'rgba(255, 255, 255, 1.0)'    // White
                    ));

                    // Scatter plot with dynamic color coding
                    this.map.addLayer({
                        id: 'collisions-scatter',
                        type: 'circle',
                        source: 'collisions',
                        layout: { visibility: 'visible' },
                        paint: {
                            'circle-radius': [
                                'interpolate', ['linear'], ['zoom'],
                                9, 3,
                                10, 5,
                                13, 6,
                                15, 7
                            ],
                            'circle-blur': [
                                'interpolate', ['linear'], ['zoom'],
                                10, 0.8,    // High blur at low zoom (cloud effect)
                                13, 0.4,    // Medium blur
                                15, 0.1     // Low blur at high zoom (individual points visible)
                            ],
                            'circle-color': [
                                'case',
                                ['==', ['get', 'collision_type'], null], '#8090a0',
                                [
                                    'match',
                                    ['get', 'collision_type'],
                                    'vehicle-to-vehicle', '#4a90d9',
                                    'vehicle-pedestrian', '#e05d5d',
                                    'vehicle-motorcycle', '#f0a040',
                                    'vehicle-bicycle', '#50b080',
                                    'other', '#8090a0',
                                    '#8090a0'
                                ]
                            ],
                            'circle-opacity': [
                                'interpolate', ['linear'], ['zoom'],
                                10, 0.4,    // Start visible with cloud effect
                                11, 0.5,    // Slightly more visible
                                12, 0.55,   // Transition zone
                                13, [       // At zoom 13+: check if selected
                                    'case',
                                    ['boolean', ['feature-state', 'selected'], false],
                                    1.0,    // Selected: 100% opaque
                                    0.3     // Not selected: 30% opaque
                                ],
                                14, [
                                    'case',
                                    ['boolean', ['feature-state', 'selected'], false],
                                    1.0,    // Selected: 100% opaque
                                    0.5     // Not selected: 50% opaque
                                ],
                                15, [
                                    'case',
                                    ['boolean', ['feature-state', 'selected'], false],
                                    1.0,    // Selected: 100% opaque
                                    0.65    // Not selected: 65% opaque
                                ],
                                16, [
                                    'case',
                                    ['boolean', ['feature-state', 'selected'], false],
                                    1.0,    // Selected: 100% opaque
                                    0.8     // Not selected: 80% opaque
                                ],
                                17, [
                                    'case',
                                    ['boolean', ['feature-state', 'selected'], false],
                                    1.0,    // Selected: 100% opaque
                                    0.85    // Not selected: 85% opaque
                                ]
                            ],
                            'circle-stroke-color': [
                                'case',
                                ['boolean', ['feature-state', 'selected'], false],
                                // When selected: use neon version of collision type color
                                [
                                    'match', ['get', 'collision_type'],
                                    'vehicle-to-vehicle', '#00BFFF',      // Electric blue
                                    'vehicle-pedestrian', '#FF0000',      // Electric red
                                    'vehicle-motorcycle', '#FF6400',      // Electric orange
                                    'vehicle-bicycle', '#00FF00',         // Electric green
                                    'other', '#FFFFFF',                   // White
                                    '#FFFFFF'                             // Default white
                                ],
                                // When not selected: white
                                '#FFFFFF'
                            ],
                            'circle-stroke-width': [
                                'case',
                                ['boolean', ['feature-state', 'selected'], false],
                                3,  // Keep stroke only for selected points
                                0   // No stroke for unselected points
                            ],
                            'circle-stroke-opacity': [
                                'case',
                                ['boolean', ['feature-state', 'selected'], false],
                                1.0,  // Full opacity when selected
                                0     // No stroke opacity for unselected
                            ]
                        }
                    });

                    // Invisible hover detection layer (always visible for mouse events)
                    this.map.addLayer({
                        id: 'collisions-hover',
                        type: 'circle',
                        source: 'collisions',
                        layout: { visibility: 'visible' },
                        paint: {
                            'circle-radius': [
                                'interpolate', ['linear'], ['zoom'],
                                10, 10,
                                15, 18
                            ],
                            'circle-opacity': 0,
                            'circle-stroke-width': 0
                        }
                    });

                    // Create reusable popup for hover tooltips
                    this.popup = new maplibregl.Popup({
                        closeButton: false,    // No close button (auto-dismiss on mouseleave)
                        closeOnClick: false,   // Don't close when map is clicked
                        offset: 15,            // Offset from cursor (px)
                        className: 'collision-tooltip'  // Custom CSS class
                    });

                    this.updateMapData();
                    this.updateLegend(); // Initialize legend with default color scheme
                });

                // Map updates quickly (200ms)
                this.map.on('moveend', this.debounce(() => this.updateMapData(), CONFIG.DEBOUNCE_DELAY));
                this.map.on('zoomend', this.debounce(() => this.updateMapData(), CONFIG.DEBOUNCE_DELAY));

                // Table updates more slowly (500ms) - separate debounce for better performance
                this.map.on('moveend', this.debounce(() => {
                    const viewport = this.getViewport();
                    const filteredData = this.getFilteredData(viewport);
                    this.updateDataTable(filteredData);
                }, 500));
                this.map.on('zoomend', this.debounce(() => {
                    const viewport = this.getViewport();
                    const filteredData = this.getFilteredData(viewport);
                    this.updateDataTable(filteredData);
                }, 500));

                this.map.on('click', 'collisions-scatter', (e) => {
                    if (e.features.length > 0) {
                        const feature = e.features[0];
                        const drNumber = feature.properties.dr_number;

                        // Remove previous highlight
                        if (this.selectedCollisionId) {
                            this.map.setFeatureState(
                                { source: 'collisions', id: this.selectedCollisionId },
                                { selected: false }
                            );
                        }

                        // Add new highlight
                        this.selectedCollisionId = feature.id;
                        this.map.setFeatureState(
                            { source: 'collisions', id: feature.id },
                            { selected: true }
                        );

                        // Highlight corresponding table row
                        this.highlightTableRow(drNumber);

                        // Show detail panel
                        this.showCollisionDetail(feature.properties);
                    }
                });

                // Track last hover position to avoid redundant updates
                this.lastHoverCoords = null;

                // Hover tooltip on points layer
                this.map.on('mousemove', 'collisions-hover', (e) => {
                    if (e.features.length > 0) {
                        // Change cursor
                        this.map.getCanvas().style.cursor = 'pointer';

                        // Check if mouse moved to different point (avoid redundant updates)
                        const coords = e.lngLat;
                        const coordsKey = `${coords.lng.toFixed(6)},${coords.lat.toFixed(6)}`;

                        if (this.lastHoverCoords === coordsKey) return;
                        this.lastHoverCoords = coordsKey;

                        // Get current zoom level
                        const currentZoom = this.map.getZoom();

                        // Show tooltip when zoomed in enough to see individual dots
                        if (currentZoom >= 14) {
                            // Show individual collision tooltip ONLY
                            const feature = e.features[0];
                            this.popup
                                .setLngLat(e.lngLat)
                                .setHTML(this.formatTooltipHTMLForSingle(feature))
                                .addTo(this.map);
                        }
                        // No tooltip at lower zoom levels
                    }
                });

                // Remove tooltip when mouse leaves points
                this.map.on('mouseleave', 'collisions-hover', () => {
                    this.map.getCanvas().style.cursor = '';
                    this.lastHoverCoords = null;
                    this.popup.remove();
                });
            }

            getViewport() {
                const bounds = this.map.getBounds();
                return {
                    minX: bounds.getWest(),
                    minY: bounds.getSouth(),
                    maxX: bounds.getEast(),
                    maxY: bounds.getNorth()
                };
            }

            // Generate deterministic pseudo-random offset based on seed
            generateOffset(seed, maxOffset) {
                // Simple pseudo-random number generator using seed
                const x = Math.sin(seed) * 10000;
                const y = Math.sin(seed * 1.5) * 10000;

                const randomX = (x - Math.floor(x)) * 2 - 1; // Range: -1 to 1
                const randomY = (y - Math.floor(y)) * 2 - 1; // Range: -1 to 1

                return {
                    lon: randomX * maxOffset,
                    lat: randomY * maxOffset
                };
            }

            // Calculate jitter radius based on zoom level
            getJitterRadius(zoom) {
                // Use constant radius at all zoom levels for consistent geographic accuracy
                // At zoom 16+: ~11 meters (0.0001 degrees)
                // At zoom 13-15: ~11 meters (constant for street-level viewing)
                // At zoom 9-12: ~11-13 meters (very gentle increase)
                const baseRadius = 0.0001; // ~11 meters in degrees at LA latitude

                // Add very gentle scaling only at extremely low zoom
                // This keeps points separate visually without moving them far geographically
                if (zoom < 12) {
                    // Add only 20% more jitter at zoom 9 vs zoom 16
                    const gentleFactor = 1 + (0.2 * (12 - zoom) / 12);
                    return baseRadius * gentleFactor;
                }

                return baseRadius;
            }

            /**
             * Filter by hour - called when clicking on hour chart bar
             */
            filterByHour(hour) {
                // Map hour to time bucket
                const timeBucketMap = {
                    0: 'EARLY_MORNING', 1: 'EARLY_MORNING', 2: 'EARLY_MORNING',
                    3: 'EARLY_MORNING', 4: 'EARLY_MORNING', 5: 'EARLY_MORNING',
                    6: 'AM_PEAK', 7: 'AM_PEAK', 8: 'AM_PEAK', 9: 'AM_PEAK',
                    10: 'MIDDAY', 11: 'MIDDAY', 12: 'MIDDAY', 13: 'MIDDAY', 14: 'MIDDAY',
                    15: 'PM_PEAK', 16: 'PM_PEAK', 17: 'PM_PEAK', 18: 'PM_PEAK',
                    19: 'EVENING', 20: 'EVENING', 21: 'EVENING',
                    22: 'LATE_NIGHT', 23: 'LATE_NIGHT'
                };

                const bucket = timeBucketMap[hour];

                // Update UI chips
                document.querySelectorAll('#timeFilters .chip').forEach(chip => {
                    const isMatch = chip.dataset.bucket === bucket;
                    chip.classList.toggle('active', isMatch);
                    chip.setAttribute('aria-checked', isMatch);
                });

                // Update filter state
                this.activeFilters.timeBuckets = [bucket];
                this.updateMapData();

                // Show toast notification
                this.showFilterToast(`Filtered to ${this.formatTimeBucketLabel(bucket)}`);
            }

            /**
             * Filter by day of week - called when clicking on dow chart bar
             */
            filterByDayOfWeek(dayIndex) {
                const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                const isWeekend = dayIndex === 0 || dayIndex === 6;

                // Update chip UI
                const weekdayChip = document.querySelector('#dayFilters .chip[data-day="weekday"]');
                const weekendChip = document.querySelector('#dayFilters .chip[data-day="weekend"]');

                if (isWeekend) {
                    weekdayChip.classList.remove('active');
                    weekdayChip.setAttribute('aria-checked', 'false');
                    weekendChip.classList.add('active');
                    weekendChip.setAttribute('aria-checked', 'true');
                } else {
                    weekdayChip.classList.add('active');
                    weekdayChip.setAttribute('aria-checked', 'true');
                    weekendChip.classList.remove('active');
                    weekendChip.setAttribute('aria-checked', 'false');
                }

                // Update filter state
                this.activeFilters.weekday = !isWeekend;
                this.activeFilters.weekend = isWeekend;
                this.updateMapData();

                // Show toast notification
                this.showFilterToast(`Filtered to ${dayNames[dayIndex]}s (${isWeekend ? 'weekends' : 'weekdays'})`);
            }

            /**
             * Format time bucket for display
             */
            formatTimeBucketLabel(bucket) {
                const labels = {
                    'EARLY_MORNING': 'Early Morning (12am-6am)',
                    'AM_PEAK': 'AM Peak (6am-10am)',
                    'MIDDAY': 'Midday (10am-3pm)',
                    'PM_PEAK': 'PM Peak (3pm-7pm)',
                    'EVENING': 'Evening (7pm-10pm)',
                    'LATE_NIGHT': 'Late Night (10pm-12am)'
                };
                return labels[bucket] || bucket;
            }

            /**
             * Show toast notification for filter changes
             */
            showFilterToast(message) {
                const existing = document.getElementById('filterToast');
                if (existing) existing.remove();

                const toast = document.createElement('div');
                toast.id = 'filterToast';
                toast.setAttribute('role', 'status');
                toast.setAttribute('aria-live', 'polite');
                toast.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(var(--color-accent-olive-rgb, 85, 107, 47), 0.95);
                    background: #556b2f;
                    color: white;
                    padding: 12px 24px;
                    border-radius: 8px;
                    font-size: 14px;
                    z-index: 9999;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                    animation: slideUpToast 0.3s ease-out;
                `;
                toast.textContent = message;

                // Add animation keyframes if not present
                if (!document.getElementById('toastStyles')) {
                    const style = document.createElement('style');
                    style.id = 'toastStyles';
                    style.textContent = `
                        @keyframes slideUpToast {
                            from { transform: translateX(-50%) translateY(20px); opacity: 0; }
                            to { transform: translateX(-50%) translateY(0); opacity: 1; }
                        }
                    `;
                    document.head.appendChild(style);
                }

                document.body.appendChild(toast);

                // Auto-dismiss after 3 seconds
                setTimeout(() => toast.remove(), 3000);
            }

            async updateMapData() {
                if (!this.map || !this.map.getSource('collisions')) return;

                const viewport = this.getViewport();

                const intersectingTiles = this.spatialIndex.search(viewport);
                const tilesToLoad = intersectingTiles
                    .map(item => item.tile)
                    .filter(tile => !this.loadedTiles.has(tile));

                if (tilesToLoad.length > 0) {
                    await this.loadTiles(tilesToLoad);
                }

                const visibleData = this.getFilteredData(viewport);

                // Get current zoom level for conditional aggregation
                const currentZoom = this.map.getZoom();

                // Conditional aggregation based on zoom level
                if (currentZoom < 15) {
                    // LOW/MEDIUM ZOOM: Aggregate for performance and heatmap
                    const collisionCounts = new Map();
                    visibleData.forEach(feature => {
                        const [lon, lat] = feature.geometry.coordinates;
                        // Round to 4 decimal places (~10m precision)
                        const key = `${lon.toFixed(4)},${lat.toFixed(4)}`;
                        collisionCounts.set(key, (collisionCounts.get(key) || 0) + 1);
                    });

                    // Add density property to features
                    visibleData.forEach(feature => {
                        const [lon, lat] = feature.geometry.coordinates;
                        const key = `${lon.toFixed(4)},${lat.toFixed(4)}`;
                        feature.properties._density = collisionCounts.get(key) || 1;
                    });
                } else {
                    // HIGH ZOOM (15+): No aggregation, individual points only
                    visibleData.forEach(feature => {
                        feature.properties._density = 1;  // All points are individual
                    });
                }

                // Apply spatial jittering for overlapping points
                const jitterRadius = this.getJitterRadius(currentZoom);

                visibleData.forEach(feature => {
                    const [lon, lat] = feature.geometry.coordinates;
                    const density = feature.properties._density;

                    // Only jitter if multiple collisions at same location
                    if (density > 1) {
                        // Use DR number as seed for deterministic offset
                        const drNumber = feature.properties.dr_number;
                        const seed = parseInt(drNumber.replace(/\D/g, '')) || 0;

                        // Generate offset
                        const offset = this.generateOffset(seed, jitterRadius);

                        // Apply offset to coordinates
                        feature.geometry.coordinates = [
                            lon + offset.lon,
                            lat + offset.lat
                        ];
                    }
                });

                const sampledData = this.sampleData(visibleData, CONFIG.MAX_POINTS_TO_RENDER);

                this.map.getSource('collisions').setData({
                    type: 'FeatureCollection',
                    features: sampledData
                });

                document.getElementById('visibleCollisions').textContent =
                    visibleData.length.toLocaleString();

                const samplingIndicator = document.getElementById('samplingIndicator');
                if (sampledData.length < visibleData.length) {
                    samplingIndicator.style.display = 'inline';
                    samplingIndicator.textContent =
                        ` • Showing ${sampledData.length.toLocaleString()} of ${visibleData.length.toLocaleString()}`;
                } else {
                    samplingIndicator.style.display = 'none';
                }

                // Determine chart data based on chartDataScope setting
                let chartData;
                if (this.chartDataScope === 'all') {
                    // Get all filtered data without viewport restrictions
                    const allViewport = {
                        minX: -180, maxX: 180,
                        minY: -90, maxY: 90
                    };
                    chartData = this.getFilteredData(allViewport);
                } else {
                    // Use viewport-filtered data (default)
                    chartData = visibleData;
                }

                this.updateCharts(chartData);
                this.updateViewportKPIs(visibleData); // Update viewport KPIs
                // Table update moved to separate debounced event (500ms) for better performance
            }

            /**
             * Load tiles with retry logic and exponential backoff
             */
            async loadTiles(tileFilenames) {
                const MAX_RETRIES = 3;
                const BASE_DELAY = 500; // ms
                let failedTiles = [];

                const loadTileWithRetry = async (filename, attempt = 1) => {
                    try {
                        const response = await fetch(`../assets/collisions/tiles/${filename}`);
                        if (!response.ok) {
                            throw new Error(`HTTP ${response.status}`);
                        }
                        const geojson = await response.json();
                        this.loadedTiles.set(filename, geojson);
                        return true;
                    } catch (error) {
                        if (attempt < MAX_RETRIES) {
                            // Exponential backoff: 500ms, 1000ms, 2000ms
                            const delay = BASE_DELAY * Math.pow(2, attempt - 1);
                            await new Promise(resolve => setTimeout(resolve, delay));
                            return loadTileWithRetry(filename, attempt + 1);
                        }
                        console.error(`Failed to load tile ${filename} after ${MAX_RETRIES} attempts:`, error);
                        failedTiles.push(filename);
                        return false;
                    }
                };

                const tilePromises = tileFilenames.map(filename => loadTileWithRetry(filename));
                await Promise.all(tilePromises);

                // Show user feedback if tiles failed to load
                if (failedTiles.length > 0) {
                    this.showTileLoadError(failedTiles.length);
                }
            }

            /**
             * Display temporary error message for failed tile loads
             */
            showTileLoadError(count) {
                const existing = document.getElementById('tileLoadError');
                if (existing) existing.remove();

                const errorDiv = document.createElement('div');
                errorDiv.id = 'tileLoadError';
                errorDiv.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    left: 50%;
                    transform: translateX(-50%);
                    background: rgba(220, 53, 69, 0.95);
                    color: white;
                    padding: 12px 24px;
                    border-radius: 8px;
                    font-size: 14px;
                    z-index: 9999;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.3);
                `;
                errorDiv.textContent = `${count} tile${count > 1 ? 's' : ''} failed to load. Some collision data may be missing.`;
                document.body.appendChild(errorDiv);

                // Auto-dismiss after 5 seconds
                setTimeout(() => errorDiv.remove(), 5000);
            }

            getFilteredData(viewport) {
                // Gather all features from loaded tiles
                const allFeatures = [];
                for (const geojson of this.loadedTiles.values()) {
                    allFeatures.push(...geojson.features);
                }

                // Deduplicate by DR number FIRST (before any filtering)
                const uniqueFeaturesMap = new Map();
                allFeatures.forEach(feature => {
                    const dr = feature.properties.dr_number;
                    if (dr && !uniqueFeaturesMap.has(dr)) {
                        uniqueFeaturesMap.set(dr, feature);
                    } else if (!dr) {
                        // If no DR number, include it (shouldn't happen but be safe)
                        uniqueFeaturesMap.set(JSON.stringify(feature.properties), feature);
                    }
                });

                const dedupedFeatures = Array.from(uniqueFeaturesMap.values());

                // Single-pass filtering - combines all filters into one iteration for 10-15x performance improvement
                const filtered = dedupedFeatures.filter(feature => {
                    const [lon, lat] = feature.geometry.coordinates;
                    const props = feature.properties;

                    // Viewport check (most likely to fail, check first for early exit)
                    if (lon < viewport.minX || lon > viewport.maxX ||
                        lat < viewport.minY || lat > viewport.maxY) {
                        return false;
                    }

                    // Date filters
                    if (this.activeFilters.dateStart && props.date_occ < this.activeFilters.dateStart) {
                        return false;
                    }
                    if (this.activeFilters.dateEnd && props.date_occ > this.activeFilters.dateEnd) {
                        return false;
                    }

                    // Time bucket filter
                    if (this.activeFilters.timeBuckets &&
                        this.activeFilters.timeBuckets.length > 0 &&
                        this.activeFilters.timeBuckets.length < 6 &&
                        !this.activeFilters.timeBuckets.includes(props.time_bucket)) {
                        return false;
                    }

                    // Day of week filter
                    if (this.activeFilters.weekday !== undefined || this.activeFilters.weekend !== undefined) {
                        const isWeekend = props.is_weekend;
                        if (this.activeFilters.weekday && this.activeFilters.weekend) {
                            // Both enabled, pass
                        } else if (this.activeFilters.weekday && isWeekend) {
                            return false;
                        } else if (this.activeFilters.weekend && !isWeekend) {
                            return false;
                        } else if (!this.activeFilters.weekday && !this.activeFilters.weekend) {
                            return false;
                        }
                    }

                    // Collision type filter
                    if (this.activeFilters.collisionTypes &&
                        this.activeFilters.collisionTypes.length > 0) {
                        const collisionType = props.collision_type || 'other';
                        if (!this.activeFilters.collisionTypes.includes(collisionType)) {
                            return false;
                        }
                    }

                    // Severity filter
                    if (this.activeFilters.severityLevels &&
                        this.activeFilters.severityLevels.length > 0) {
                        // Treat null/undefined severity as 'unknown'
                        const severity = props.severity || 'unknown';
                        if (!this.activeFilters.severityLevels.includes(severity)) {
                            return false;
                        }
                    }

                    // Hit & Run filter
                    if (this.activeFilters.showHitAndRun && !props.is_hit_and_run) {
                        return false;
                    }

                    // DUI filter
                    if (this.activeFilters.showDUI && !props.is_dui) {
                        return false;
                    }

                    return true;
                });

                return filtered;
            }

            sampleData(data, maxPoints) {
                if (data.length <= maxPoints) {
                    return data;
                }

                const step = data.length / maxPoints;
                const sampled = [];
                for (let i = 0; i < maxPoints; i++) {
                    sampled.push(data[Math.floor(i * step)]);
                }
                return sampled;
            }

            initCharts() {
                this.charts.hour = new Chart(document.getElementById('hourChart'), {
                    type: 'bar',
                    data: {
                        labels: Array.from({length: 24}, (_, i) => {
                            if (i === 0) return '12am';
                            if (i < 12) return `${i}am`;
                            if (i === 12) return '12pm';
                            return `${i-12}pm`;
                        }),
                        datasets: [
                            {
                                label: 'Vehicle-Vehicle',
                                data: new Array(24).fill(0),
                                backgroundColor: 'rgba(52, 152, 219, 0.7)',
                                borderColor: 'rgba(52, 152, 219, 1)',
                                borderWidth: 1
                            },
                            {
                                label: 'Vehicle-Pedestrian',
                                data: new Array(24).fill(0),
                                backgroundColor: 'rgba(231, 76, 60, 0.7)',
                                borderColor: 'rgba(231, 76, 60, 1)',
                                borderWidth: 1
                            },
                            {
                                label: 'Vehicle-Motorcycle',
                                data: new Array(24).fill(0),
                                backgroundColor: 'rgba(255, 100, 0, 0.7)',
                                borderColor: 'rgba(255, 100, 0, 1)',
                                borderWidth: 1
                            },
                            {
                                label: 'Vehicle-Bicycle',
                                data: new Array(24).fill(0),
                                backgroundColor: 'rgba(46, 204, 113, 0.7)',
                                borderColor: 'rgba(46, 204, 113, 1)',
                                borderWidth: 1
                            },
                            {
                                label: 'Other',
                                data: new Array(24).fill(0),
                                backgroundColor: 'rgba(149, 165, 166, 0.7)',
                                borderColor: 'rgba(149, 165, 166, 1)',
                                borderWidth: 1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: { stacked: true },
                            y: {
                                stacked: true,
                                beginAtZero: true
                            }
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'bottom',
                                labels: {
                                    boxWidth: 12,
                                    font: { size: 10 },
                                    padding: 8
                                }
                            }
                        },
                        onClick: (event, elements) => {
                            if (elements.length > 0) {
                                const index = elements[0].index;
                                this.filterByHour(index);
                            }
                        }
                    }
                });

                this.charts.dow = new Chart(document.getElementById('dowChart'), {
                    type: 'bar',
                    data: {
                        labels: ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'],
                        datasets: [
                            {
                                label: 'Vehicle-Vehicle',
                                data: new Array(7).fill(0),
                                backgroundColor: 'rgba(52, 152, 219, 0.7)',
                                borderColor: 'rgba(52, 152, 219, 1)',
                                borderWidth: 1
                            },
                            {
                                label: 'Vehicle-Pedestrian',
                                data: new Array(7).fill(0),
                                backgroundColor: 'rgba(231, 76, 60, 0.7)',
                                borderColor: 'rgba(231, 76, 60, 1)',
                                borderWidth: 1
                            },
                            {
                                label: 'Vehicle-Motorcycle',
                                data: new Array(7).fill(0),
                                backgroundColor: 'rgba(255, 100, 0, 0.7)',
                                borderColor: 'rgba(255, 100, 0, 1)',
                                borderWidth: 1
                            },
                            {
                                label: 'Vehicle-Bicycle',
                                data: new Array(7).fill(0),
                                backgroundColor: 'rgba(46, 204, 113, 0.7)',
                                borderColor: 'rgba(46, 204, 113, 1)',
                                borderWidth: 1
                            },
                            {
                                label: 'Other',
                                data: new Array(7).fill(0),
                                backgroundColor: 'rgba(149, 165, 166, 0.7)',
                                borderColor: 'rgba(149, 165, 166, 1)',
                                borderWidth: 1
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: { stacked: true },
                            y: {
                                stacked: true,
                                beginAtZero: true
                            }
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'bottom',
                                labels: {
                                    boxWidth: 12,
                                    font: { size: 10 },
                                    padding: 8
                                }
                            }
                        },
                        onClick: (event, elements) => {
                            if (elements.length > 0) {
                                const index = elements[0].index;
                                this.filterByDayOfWeek(index);
                            }
                        }
                    }
                });

                this.charts.year = new Chart(document.getElementById('yearChart'), {
                    type: 'line',
                    data: {
                        labels: [],
                        datasets: [
                            {
                                label: 'Vehicle-Vehicle',
                                data: [],
                                borderColor: 'rgba(52, 152, 219, 1)',
                                backgroundColor: 'rgba(52, 152, 219, 0.3)',
                                tension: 0.4,
                                fill: true
                            },
                            {
                                label: 'Vehicle-Pedestrian',
                                data: [],
                                borderColor: 'rgba(231, 76, 60, 1)',
                                backgroundColor: 'rgba(231, 76, 60, 0.3)',
                                tension: 0.4,
                                fill: true
                            },
                            {
                                label: 'Vehicle-Motorcycle',
                                data: [],
                                borderColor: 'rgba(255, 100, 0, 1)',
                                backgroundColor: 'rgba(255, 100, 0, 0.3)',
                                tension: 0.4,
                                fill: true
                            },
                            {
                                label: 'Vehicle-Bicycle',
                                data: [],
                                borderColor: 'rgba(46, 204, 113, 1)',
                                backgroundColor: 'rgba(46, 204, 113, 0.3)',
                                tension: 0.4,
                                fill: true
                            },
                            {
                                label: 'Other',
                                data: [],
                                borderColor: 'rgba(149, 165, 166, 1)',
                                backgroundColor: 'rgba(149, 165, 166, 0.3)',
                                tension: 0.4,
                                fill: true
                            }
                        ]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                stacked: true,
                                beginAtZero: true
                            }
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'bottom',
                                labels: {
                                    boxWidth: 12,
                                    font: { size: 10 },
                                    padding: 8
                                }
                            }
                        }
                    }
                });
            }

            updateChartsFromOverview() {
                this.charts.hour.data.datasets[0].data = this.overview.hourly_counts;
                this.charts.hour.update();

                this.charts.dow.data.datasets[0].data = this.overview.dow_counts;
                this.charts.dow.update();

                this.charts.year.data.labels = this.overview.year_counts.map(y => y.year);
                this.charts.year.data.datasets[0].data = this.overview.year_counts.map(y => y.count);
                this.charts.year.update();
            }

            updateCharts(filteredData) {
                // Initialize counts by collision type (all 5 types)
                const collisionTypes = ['vehicle-to-vehicle', 'vehicle-pedestrian', 'vehicle-motorcycle', 'vehicle-bicycle', 'other'];

                // Hourly counts by type: { 'vehicle-to-vehicle': [24 hours], ... }
                const hourlyCountsByType = {};
                collisionTypes.forEach(type => {
                    hourlyCountsByType[type] = new Array(24).fill(0);
                });

                // Day of week counts by type
                const dowCountsByType = {};
                collisionTypes.forEach(type => {
                    dowCountsByType[type] = new Array(7).fill(0);
                });

                // Year counts by type
                const yearCountsByType = {};
                collisionTypes.forEach(type => {
                    yearCountsByType[type] = {};
                });

                // Aggregate data by type
                filteredData.forEach(feature => {
                    const props = feature.properties;
                    let collisionType = props.collision_type || 'other';

                    // Include all 5 types
                    if (!collisionTypes.includes(collisionType)) {
                        // Shouldn't happen, but fallback to 'other'
                        collisionType = 'other';
                    }

                    // Hourly
                    if (props.hour !== null) {
                        hourlyCountsByType[collisionType][props.hour]++;
                    }

                    // Day of week
                    dowCountsByType[collisionType][props.dow]++;

                    // Year
                    yearCountsByType[collisionType][props.year] =
                        (yearCountsByType[collisionType][props.year] || 0) + 1;
                });

                // Update hourly chart datasets
                this.charts.hour.data.datasets[0].data = hourlyCountsByType['vehicle-to-vehicle'];
                this.charts.hour.data.datasets[1].data = hourlyCountsByType['vehicle-pedestrian'];
                this.charts.hour.data.datasets[2].data = hourlyCountsByType['vehicle-motorcycle'];
                this.charts.hour.data.datasets[3].data = hourlyCountsByType['vehicle-bicycle'];
                this.charts.hour.data.datasets[4].data = hourlyCountsByType['other'];
                this.charts.hour.update();

                // Update day of week chart datasets
                this.charts.dow.data.datasets[0].data = dowCountsByType['vehicle-to-vehicle'];
                this.charts.dow.data.datasets[1].data = dowCountsByType['vehicle-pedestrian'];
                this.charts.dow.data.datasets[2].data = dowCountsByType['vehicle-motorcycle'];
                this.charts.dow.data.datasets[3].data = dowCountsByType['vehicle-bicycle'];
                this.charts.dow.data.datasets[4].data = dowCountsByType['other'];
                this.charts.dow.update();

                // Update year chart datasets
                // Collect all years across all types
                const allYears = new Set();
                collisionTypes.forEach(type => {
                    Object.keys(yearCountsByType[type]).forEach(year => allYears.add(year));
                });
                const years = Array.from(allYears).sort();

                this.charts.year.data.labels = years;
                this.charts.year.data.datasets[0].data = years.map(y => yearCountsByType['vehicle-to-vehicle'][y] || 0);
                this.charts.year.data.datasets[1].data = years.map(y => yearCountsByType['vehicle-pedestrian'][y] || 0);
                this.charts.year.data.datasets[2].data = years.map(y => yearCountsByType['vehicle-motorcycle'][y] || 0);
                this.charts.year.data.datasets[3].data = years.map(y => yearCountsByType['vehicle-bicycle'][y] || 0);
                this.charts.year.data.datasets[4].data = years.map(y => yearCountsByType['other'][y] || 0);
                this.charts.year.update();
            }

            initChartControls() {
                // Data scope controls
                document.querySelectorAll('[data-scope]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        // Toggle active state
                        document.querySelectorAll('[data-scope]').forEach(b =>
                            b.classList.remove('active'));
                        e.target.classList.add('active');

                        // Update data scope setting
                        this.chartDataScope = e.target.dataset.scope;

                        // Refresh charts
                        this.updateMapData();
                    });
                });

                // Display mode controls
                document.querySelectorAll('[data-mode]').forEach(btn => {
                    btn.addEventListener('click', (e) => {
                        // Toggle active state
                        document.querySelectorAll('[data-mode]').forEach(b =>
                            b.classList.remove('active'));
                        e.target.classList.add('active');

                        // Update display mode
                        this.chartDisplayMode = e.target.dataset.mode;

                        // Update chart options
                        this.updateChartDisplayMode();
                    });
                });
            }

            updateChartDisplayMode() {
                const mode = this.chartDisplayMode;

                ['hour', 'dow', 'year'].forEach(chartKey => {
                    const chart = this.charts[chartKey];

                    if (mode === 'stacked') {
                        // Enable stacking
                        chart.options.scales.y.stacked = true;
                        if (chart.options.scales.x) {
                            chart.options.scales.x.stacked = true;
                        }
                        // Show all datasets
                        chart.data.datasets.forEach(ds => {
                            ds.hidden = false;
                        });
                    } else if (mode === 'grouped') {
                        // Disable stacking
                        chart.options.scales.y.stacked = false;
                        if (chart.options.scales.x) {
                            chart.options.scales.x.stacked = false;
                        }
                        // Show all datasets
                        chart.data.datasets.forEach(ds => {
                            ds.hidden = false;
                        });
                    } else if (mode === 'total') {
                        // Show only aggregated data (hide datasets except first)
                        chart.data.datasets.forEach((ds, i) => {
                            ds.hidden = i > 0;  // Hide all except first
                        });
                        // Re-enable stacking for cleaner look
                        chart.options.scales.y.stacked = true;
                        if (chart.options.scales.x) {
                            chart.options.scales.x.stacked = true;
                        }
                    }

                    chart.update();
                });
            }

            updateViewportKPIs(visibleData) {
                // Early exit for empty viewport
                if (!visibleData || visibleData.length === 0) {
                    document.getElementById('topArea').textContent = 'N/A';
                    document.getElementById('topCollisionType').textContent = 'N/A';
                    document.getElementById('viewportPeakHour').textContent = 'N/A';
                    document.getElementById('topSeverity').textContent = 'N/A';
                    return;
                }

                // Single-pass aggregation for all 4 KPIs
                const areaCounts = new Map();
                const typeCounts = new Map();
                const hourCounts = new Array(24).fill(0);
                const severityCounts = new Map();

                visibleData.forEach(feature => {
                    const props = feature.properties;

                    // Area aggregation
                    if (props.area_name) {
                        areaCounts.set(props.area_name, (areaCounts.get(props.area_name) || 0) + 1);
                    }

                    // Collision type aggregation
                    const collisionType = props.collision_type || 'other';
                    typeCounts.set(collisionType, (typeCounts.get(collisionType) || 0) + 1);

                    // Hour aggregation
                    if (props.hour !== null && props.hour !== undefined &&
                        props.hour >= 0 && props.hour <= 23) {
                        hourCounts[props.hour]++;
                    }

                    // Severity aggregation
                    if (props.severity) {
                        severityCounts.set(props.severity, (severityCounts.get(props.severity) || 0) + 1);
                    }
                });

                // KPI 1: Top Area
                const topArea = this.findTopEntry(areaCounts);
                document.getElementById('topArea').textContent = topArea || 'N/A';

                // KPI 2: Top Collision Type
                const topType = this.findTopEntry(typeCounts);
                document.getElementById('topCollisionType').textContent =
                    this.formatCollisionType(topType);

                // KPI 3: Peak Hour (handle all-zero case)
                const maxHourCount = Math.max(...hourCounts);
                if (maxHourCount === 0) {
                    document.getElementById('viewportPeakHour').textContent = 'N/A';
                } else {
                    const peakHourIndex = hourCounts.indexOf(maxHourCount);
                    document.getElementById('viewportPeakHour').textContent =
                        this.formatHour(peakHourIndex);
                }

                // KPI 4: Dominant Severity with Percentage
                const topSeverity = this.findTopEntry(severityCounts);
                if (topSeverity) {
                    const severityPercentage = (severityCounts.get(topSeverity) / visibleData.length) * 100;
                    document.getElementById('topSeverity').innerHTML =
                        `${this.formatSeverity(topSeverity)} <span style="font-size:0.75em;opacity:0.8">(${severityPercentage.toFixed(0)}%)</span>`;
                } else {
                    document.getElementById('topSeverity').textContent = 'N/A';
                }
            }

            findTopEntry(countsMap) {
                if (countsMap.size === 0) return null;

                let maxCount = 0;
                let topEntry = null;

                countsMap.forEach((count, key) => {
                    if (count > maxCount) {
                        maxCount = count;
                        topEntry = key;
                    }
                });

                return topEntry;
            }

            formatCollisionType(type) {
                if (!type) return 'N/A';
                const typeMap = {
                    'vehicle-to-vehicle': 'Vehicle-Vehicle',
                    'vehicle-pedestrian': 'Vehicle-Pedestrian',
                    'vehicle-motorcycle': 'Vehicle-Motorcycle',
                    'vehicle-bicycle': 'Vehicle-Bicycle',
                    'other': 'Other'
                };
                return typeMap[type] || type;
            }

            formatSeverity(severity) {
                if (!severity) return 'Unknown';
                const severityMap = {
                    'property_damage': 'Property Dmg',
                    'minor_injury': 'Minor Injury',
                    'severe_injury': 'Severe Injury',
                    'unknown': 'Unknown'
                };
                return severityMap[severity] || 'Unknown';
            }

            formatHour(h) {
                if (h === null || h === undefined || h < 0 || h > 23) return 'N/A';
                if (h === 0) return '12am';
                if (h < 12) return `${h}am`;
                if (h === 12) return '12pm';
                return `${h-12}pm`;
            }

            attachEventListeners() {
                // Data quality banner toggle
                const banner = document.getElementById('dataQualityBanner');
                const bannerHeader = document.getElementById('dataQualityHeader');
                const showDataNotes = document.getElementById('showDataNotes');

                bannerHeader.addEventListener('click', () => {
                    banner.classList.toggle('expanded');
                });

                showDataNotes.addEventListener('click', (e) => {
                    e.preventDefault();
                    banner.classList.add('expanded');
                    banner.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                });

                // Color scheme toggle
                document.getElementById('colorByType').addEventListener('click', () => {
                    this.activeColorScheme = 'collision_type';
                    this.updateMapColors();
                    document.getElementById('colorByType').classList.add('active');
                    document.getElementById('colorByType').setAttribute('aria-pressed', 'true');
                    document.getElementById('colorByTime').classList.remove('active');
                    document.getElementById('colorByTime').setAttribute('aria-pressed', 'false');
                });

                document.getElementById('colorByTime').addEventListener('click', () => {
                    this.activeColorScheme = 'time_bucket';
                    this.updateMapColors();
                    document.getElementById('colorByTime').classList.add('active');
                    document.getElementById('colorByTime').setAttribute('aria-pressed', 'true');
                    document.getElementById('colorByType').classList.remove('active');
                    document.getElementById('colorByType').setAttribute('aria-pressed', 'false');
                });

                // Date range slider
                const startSlider = document.getElementById('dateStartSlider');
                const endSlider = document.getElementById('dateEndSlider');

                startSlider.addEventListener('input', (e) => {
                    const startVal = parseInt(e.target.value);
                    const endVal = parseInt(endSlider.value);
                    // Prevent crossing
                    if (startVal > endVal) {
                        e.target.value = endVal;
                        return;
                    }
                    document.getElementById('dateStartLabel').textContent = this.monthIndexToLabel(startVal);
                    this.activeFilters.dateStart = startVal === 0 ? null : this.monthIndexToDate(startVal);
                    this.updateSliderRange();
                    this.updateMapData();
                });

                endSlider.addEventListener('input', (e) => {
                    const endVal = parseInt(e.target.value);
                    const startVal = parseInt(startSlider.value);
                    // Prevent crossing
                    if (endVal < startVal) {
                        e.target.value = startVal;
                        return;
                    }
                    document.getElementById('dateEndLabel').textContent = this.monthIndexToLabel(endVal);
                    const maxIndex = CONFIG.DATE_SLIDER.totalMonths - 1;
                    this.activeFilters.dateEnd = endVal === maxIndex ? null : this.monthIndexToDate(endVal + 1);
                    this.updateSliderRange();
                    this.updateMapData();
                });

                // Initialize slider range highlight
                this.updateSliderRange();

                // Time of Day filter chips
                document.querySelectorAll('#timeFilters .chip').forEach(chip => {
                    chip.addEventListener('click', (e) => {
                        e.target.classList.toggle('active');
                        this.activeFilters.timeBuckets = Array.from(
                            document.querySelectorAll('#timeFilters .chip.active')
                        ).map(c => c.dataset.bucket);
                        this.updateMapData();
                    });
                });

                // Collision Type filter chips
                document.querySelectorAll('#collisionTypeFilters .chip').forEach(chip => {
                    chip.addEventListener('click', (e) => {
                        e.target.classList.toggle('active');
                        this.activeFilters.collisionTypes = Array.from(
                            document.querySelectorAll('#collisionTypeFilters .chip.active')
                        ).map(c => c.dataset.type);
                        this.updateMapData();
                    });
                });

                // Days of Week filter chips
                document.querySelectorAll('#dayFilters .chip').forEach(chip => {
                    chip.addEventListener('click', (e) => {
                        e.target.classList.toggle('active');
                        const isActive = e.target.classList.contains('active');
                        e.target.setAttribute('aria-checked', isActive);
                        this.activeFilters.weekday = document.querySelector('#dayFilters .chip[data-day="weekday"]').classList.contains('active');
                        this.activeFilters.weekend = document.querySelector('#dayFilters .chip[data-day="weekend"]').classList.contains('active');
                        this.updateMapData();
                    });
                });

                // Severity filter chips
                document.querySelectorAll('#severityFilters .chip').forEach(chip => {
                    chip.addEventListener('click', (e) => {
                        e.target.classList.toggle('active');
                        const isActive = e.target.classList.contains('active');
                        e.target.setAttribute('aria-checked', isActive);
                        this.activeFilters.severityLevels = Array.from(
                            document.querySelectorAll('#severityFilters .chip.active')
                        ).map(c => c.dataset.severity);
                        this.updateMapData();
                    });
                });

                // Special circumstances filter chips
                document.querySelectorAll('#specialFilters .chip').forEach(chip => {
                    chip.addEventListener('click', (e) => {
                        e.target.classList.toggle('active');
                        const isActive = e.target.classList.contains('active');
                        e.target.setAttribute('aria-checked', isActive);
                        this.activeFilters.showHitAndRun = document.querySelector('#specialFilters .chip[data-special="hit_and_run"]').classList.contains('active');
                        this.activeFilters.showDUI = document.querySelector('#specialFilters .chip[data-special="dui"]').classList.contains('active');
                        this.updateMapData();
                    });
                });

                document.getElementById('resetFilters').addEventListener('click', () => {
                    this.activeFilters = {
                        dateStart: null,
                        dateEnd: null,
                        timeBuckets: ['AM_PEAK', 'MIDDAY', 'PM_PEAK', 'EVENING', 'LATE_NIGHT', 'EARLY_MORNING'],
                        weekday: true,
                        weekend: true,
                        collisionTypes: ['vehicle-to-vehicle', 'vehicle-pedestrian', 'vehicle-motorcycle', 'vehicle-bicycle', 'other'],
                        severityLevels: ['property_damage', 'minor_injury', 'severe_injury', 'unknown'],
                        showHitAndRun: false,
                        showDUI: false
                    };
                    // Reset date slider
                    document.getElementById('dateStartSlider').value = 0;
                    document.getElementById('dateEndSlider').value = 182;
                    document.getElementById('dateStartLabel').textContent = 'Jan 2010';
                    document.getElementById('dateEndLabel').textContent = 'Mar 2025';
                    this.updateSliderRange();
                    // Reset all filter chips to active (except special circumstances which start inactive)
                    document.querySelectorAll('#timeFilters .chip, #dayFilters .chip, #collisionTypeFilters .chip, #severityFilters .chip').forEach(c => {
                        c.classList.add('active');
                        c.setAttribute('aria-checked', 'true');
                    });
                    // Special circumstances start inactive
                    document.querySelectorAll('#specialFilters .chip').forEach(c => {
                        c.classList.remove('active');
                        c.setAttribute('aria-checked', 'false');
                    });
                    this.updateMapData();
                });

                document.getElementById('closeDetail').addEventListener('click', (e) => {
                    e.stopPropagation();  // Prevent triggering click-outside listener
                    this.closeDetailPanel();
                });

                // Keyboard navigation: Escape to close detail panel
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'Escape') {
                        const detailPanel = document.getElementById('detailPanel');
                        if (detailPanel.style.display !== 'none') {
                            this.closeDetailPanel();
                        }
                    }
                });

                // Mobile swipe-to-dismiss for bottom sheet
                this.setupSwipeToDismiss();

                // Update aria-checked on chip toggles
                document.querySelectorAll('.chip[role="checkbox"]').forEach(chip => {
                    chip.addEventListener('click', () => {
                        const isChecked = chip.classList.contains('active');
                        chip.setAttribute('aria-checked', isChecked);
                    });
                });

                // Setup table sorting
                this.setupTableSorting();
            }

            highlightTableRow(drNumber) {
                // Remove previous highlights
                document.querySelectorAll('.collisions-table tbody tr.highlighted')
                    .forEach(r => r.classList.remove('highlighted'));

                // Add highlight to matching row
                const row = document.querySelector(
                    `.collisions-table tbody tr[data-dr-number="${drNumber}"]`
                );
                if (row) {
                    row.classList.add('highlighted');
                    row.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
                }
            }

            showCollisionDetail(props) {
                // Helper function to format boolean values
                const formatBoolean = (val) => val ? 'Yes' : 'No';

                // Helper function to format collision type
                const formatCollisionType = (type) => {
                    if (!type) return 'Unknown';
                    return type.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join('-');
                };

                // Helper function to format severity
                const formatSeverity = (severity) => {
                    if (!severity) return 'Unknown';
                    return severity.split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');
                };

                // Helper function to format time bucket
                const formatTimeBucket = (bucket) => {
                    if (!bucket) return 'Unknown';
                    const mapping = {
                        'EARLY_MORNING': 'Early Morning (12am-6am)',
                        'AM_PEAK': 'AM Peak (6am-10am)',
                        'MIDDAY': 'Midday (10am-3pm)',
                        'PM_PEAK': 'PM Peak (3pm-7pm)',
                        'EVENING': 'Evening (7pm-10pm)',
                        'LATE_NIGHT': 'Late Night (10pm-12am)'
                    };
                    return mapping[bucket] || bucket;
                };

                // Helper function to format day of week
                const formatDayOfWeek = (dow) => {
                    const days = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
                    return days[dow] || 'Unknown';
                };

                document.getElementById('detailContent').innerHTML = `
                    <div class="detail-section">
                        <h3 class="detail-section-title">Incident Information</h3>
                        <div class="detail-grid">
                            <div class="detail-row">
                                <span class="detail-label">DR Number:</span>
                                <span class="detail-value">${props.dr_number || 'N/A'}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">Date:</span>
                                <span class="detail-value">${props.date_occ ? props.date_occ.split('T')[0] : 'Unknown'}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">Time:</span>
                                <span class="detail-value">${this.formatTime(props.time_occ_minutes)}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">Hour of Day:</span>
                                <span class="detail-value">${props.hour !== null && props.hour !== undefined ? `${props.hour}:00` : 'Unknown'}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">Time Period:</span>
                                <span class="detail-value">${formatTimeBucket(props.time_bucket)}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">Day of Week:</span>
                                <span class="detail-value">${formatDayOfWeek(props.dow)}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">Weekend:</span>
                                <span class="detail-value">${formatBoolean(props.is_weekend)}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">Year:</span>
                                <span class="detail-value">${props.year || 'Unknown'}</span>
                            </div>
                        </div>
                    </div>

                    <div class="detail-section">
                        <h3 class="detail-section-title">Location Information</h3>
                        <div class="detail-grid">
                            <div class="detail-row">
                                <span class="detail-label">Address:</span>
                                <span class="detail-value">${props.address || 'Unknown'}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">Cross Street:</span>
                                <span class="detail-value">${props.cross_street || 'N/A'}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">LAPD Area:</span>
                                <span class="detail-value">${props.area_name || 'Unknown'} ${props.area_id ? `(#${props.area_id})` : ''}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">Premise:</span>
                                <span class="detail-value">${props.premise_desc || 'Unknown'}</span>
                            </div>
                        </div>
                    </div>

                    <div class="detail-section">
                        <h3 class="detail-section-title">Collision Details</h3>
                        <div class="detail-grid">
                            <div class="detail-row">
                                <span class="detail-label">Collision Type:</span>
                                <span class="detail-value">${formatCollisionType(props.collision_type)}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">Severity:</span>
                                <span class="detail-value severity-${props.severity || 'unknown'}">${formatSeverity(props.severity)}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">Pedestrian Involved:</span>
                                <span class="detail-value">${formatBoolean(props.has_pedestrian)}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">Motorcycle Involved:</span>
                                <span class="detail-value">${formatBoolean(props.has_motorcycle)}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">Bicycle Involved:</span>
                                <span class="detail-value">${formatBoolean(props.has_bicycle)}</span>
                            </div>
                        </div>
                    </div>

                    <div class="detail-section">
                        <h3 class="detail-section-title">Special Circumstances</h3>
                        <div class="detail-grid">
                            <div class="detail-row">
                                <span class="detail-label">Hit and Run:</span>
                                <span class="detail-value ${props.is_hit_and_run ? 'text-danger' : ''}">${formatBoolean(props.is_hit_and_run)}</span>
                            </div>
                            <div class="detail-row">
                                <span class="detail-label">DUI Related:</span>
                                <span class="detail-value ${props.is_dui ? 'text-danger' : ''}">${formatBoolean(props.is_dui)}</span>
                            </div>
                            ${props.mo_codes ? `
                            <div class="detail-row detail-row-full">
                                <span class="detail-label">MO Codes:</span>
                                <span class="detail-value" style="font-family: monospace; font-size: 0.85rem;">${props.mo_codes}</span>
                            </div>
                            ` : ''}
                        </div>
                    </div>
                `;

                const detailPanel = document.getElementById('detailPanel');
                detailPanel.style.display = 'block';

                // Remove previous click-outside listener if it exists
                if (this.detailPanelClickOutside) {
                    document.removeEventListener('click', this.detailPanelClickOutside);
                }

                // Add click-outside-to-close listener
                // Use setTimeout to prevent immediate closing from the same click that opened it
                setTimeout(() => {
                    this.detailPanelClickOutside = (e) => {
                        // Close if clicking outside the detail panel
                        if (!detailPanel.contains(e.target) && detailPanel.style.display === 'block') {
                            this.closeDetailPanel();
                        }
                    };
                    document.addEventListener('click', this.detailPanelClickOutside);
                }, 100);
            }

            closeDetailPanel() {
                const detailPanel = document.getElementById('detailPanel');
                detailPanel.style.display = 'none';
                detailPanel.style.transform = '';  // Reset any swipe transform

                // Remove click-outside listener
                if (this.detailPanelClickOutside) {
                    document.removeEventListener('click', this.detailPanelClickOutside);
                    this.detailPanelClickOutside = null;
                }

                // Remove map point highlight
                if (this.selectedCollisionId) {
                    this.map.setFeatureState(
                        { source: 'collisions', id: this.selectedCollisionId },
                        { selected: false }
                    );
                    this.selectedCollisionId = null;
                }

                // Remove table row highlight
                document.querySelectorAll('.collisions-table tbody tr.highlighted')
                    .forEach(r => r.classList.remove('highlighted'));
            }

            /**
             * Setup swipe-to-dismiss for mobile bottom sheet
             */
            setupSwipeToDismiss() {
                const panel = document.getElementById('detailPanel');
                let startY = 0;
                let currentY = 0;
                let isDragging = false;

                const handleTouchStart = (e) => {
                    // Only enable swipe on mobile (when bottom sheet is active)
                    if (window.innerWidth > 768) return;

                    startY = e.touches[0].clientY;
                    isDragging = true;
                    panel.style.transition = 'none';
                };

                const handleTouchMove = (e) => {
                    if (!isDragging) return;

                    currentY = e.touches[0].clientY;
                    const deltaY = currentY - startY;

                    // Only allow dragging downward
                    if (deltaY > 0) {
                        panel.style.transform = `translateY(${deltaY}px)`;
                    }
                };

                const handleTouchEnd = () => {
                    if (!isDragging) return;
                    isDragging = false;

                    const deltaY = currentY - startY;
                    panel.style.transition = 'transform 0.2s ease-out';

                    // If dragged more than 100px down, dismiss
                    if (deltaY > 100) {
                        this.closeDetailPanel();
                    } else {
                        // Snap back
                        panel.style.transform = 'translateY(0)';
                    }
                };

                panel.addEventListener('touchstart', handleTouchStart, { passive: true });
                panel.addEventListener('touchmove', handleTouchMove, { passive: true });
                panel.addEventListener('touchend', handleTouchEnd);
            }

            updateMapColors() {
                if (!this.map || !this.map.getLayer('collisions-scatter')) return;

                let colorExpression;

                if (this.activeColorScheme === 'collision_type') {
                    colorExpression = [
                        'case',
                        ['==', ['get', 'collision_type'], null], '#8090a0',
                        [
                            'match',
                            ['get', 'collision_type'],
                            'vehicle-to-vehicle', '#4a90d9',
                            'vehicle-pedestrian', '#e05d5d',
                            'vehicle-motorcycle', '#f0a040',
                            'vehicle-bicycle', '#50b080',
                            'other', '#8090a0',
                            '#8090a0'
                        ]
                    ];
                } else if (this.activeColorScheme === 'time_bucket') {
                    colorExpression = [
                        'case',
                        ['==', ['get', 'time_bucket'], null], '#8090a0',
                        [
                            'match',
                            ['get', 'time_bucket'],
                            'EARLY_MORNING', '#2c3e50',
                            'AM_PEAK', '#e67e22',
                            'MIDDAY', '#f1c40f',
                            'PM_PEAK', '#c0392b',
                            'EVENING', '#8e44ad',
                            'LATE_NIGHT', '#34495e',
                            '#8090a0'
                        ]
                    ];
                }

                this.map.setPaintProperty('collisions-scatter', 'circle-color', colorExpression);
                this.updateLegend();
            }

            updateLegend() {
                const legendEl = document.getElementById('mapLegend');
                if (!legendEl) return;

                let legendHTML = '';

                if (this.activeColorScheme === 'collision_type') {
                    legendHTML = `
                        <h4>Collision Type</h4>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #4a90d9;"></div>
                            <div class="legend-label">Vehicle-Vehicle</div>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #e05d5d;"></div>
                            <div class="legend-label">Vehicle-Pedestrian</div>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #f0a040;"></div>
                            <div class="legend-label">Vehicle-Motorcycle</div>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #50b080;"></div>
                            <div class="legend-label">Vehicle-Bicycle</div>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #8090a0;"></div>
                            <div class="legend-label">Other</div>
                        </div>
                        <div class="legend-help">
                            Heatmap (zoom out) and points (zoom in) use these colors
                        </div>
                    `;
                } else if (this.activeColorScheme === 'time_bucket') {
                    legendHTML = `
                        <h4>Time of Day</h4>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #2c3e50;"></div>
                            <div class="legend-label">Early AM (12-6am)</div>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #e67e22;"></div>
                            <div class="legend-label">AM Peak (6-10am)</div>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #f1c40f;"></div>
                            <div class="legend-label">Midday (10am-3pm)</div>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #c0392b;"></div>
                            <div class="legend-label">PM Peak (3-7pm)</div>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #8e44ad;"></div>
                            <div class="legend-label">Evening (7-10pm)</div>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: #34495e;"></div>
                            <div class="legend-label">Late Night (10pm-12am)</div>
                        </div>
                    `;
                }

                legendEl.innerHTML = legendHTML;
            }

            formatTime(minutes) {
                if (!minutes && minutes !== 0) return 'Unknown';
                const hours = Math.floor(minutes / 60);
                const mins = minutes % 60;
                const ampm = hours >= 12 ? 'pm' : 'am';
                const displayHours = hours === 0 ? 12 : hours > 12 ? hours - 12 : hours;
                return `${displayHours}:${mins.toString().padStart(2, '0')}${ampm}`;
            }

            /**
             * Format tooltip HTML for a single collision (used at high zoom)
             * Shows address, severity badge, date, and time
             */
            formatTooltipHTMLForSingle(feature) {
                const props = feature.properties;
                const timeStr = this.formatTime(props.time_occ_minutes);
                const dateStr = props.date_occ ? props.date_occ.split('T')[0] : 'Unknown';
                const severity = props.severity || 'unknown';
                const severityClass = `severity-${severity}`;
                const severityLabel = severity.split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');

                // Format collision type
                const collisionType = props.collision_type
                    ? props.collision_type.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join('-')
                    : 'Unknown';

                // Build special circumstances badges
                const badges = [];
                if (props.is_hit_and_run) badges.push('<span class="badge-warn">Hit & Run</span>');
                if (props.is_dui) badges.push('<span class="badge-warn">DUI</span>');
                const badgesHTML = badges.length > 0 ? `<div style="margin-top: 0.3rem;">${badges.join(' ')}</div>` : '';

                return `
                    <div style="padding: 0.6rem; min-width: 250px;">
                        <div style="font-size: 0.75rem; color: #999; margin-bottom: 0.2rem;">
                            ${props.area_name || 'Unknown Area'}
                        </div>
                        <div style="font-size: 0.95rem; font-weight: 600; margin-bottom: 0.5rem;">
                            ${props.address || 'Unknown Location'}
                        </div>
                        ${props.cross_street ? `<div style="font-size: 0.8rem; color: #bbb; margin-bottom: 0.5rem;">Near ${props.cross_street}</div>` : ''}
                        <div style="display: flex; gap: 0.4rem; align-items: center; flex-wrap: wrap; margin-bottom: 0.3rem;">
                            <span class="tooltip-badge ${severityClass}">${severityLabel}</span>
                            <span style="font-size: 0.8rem; color: #aaa;">${collisionType}</span>
                        </div>
                        <div style="font-size: 0.8rem; color: #999;">
                            ${dateStr} at ${timeStr}
                        </div>
                        ${badgesHTML}
                    </div>
                `;
            }

            /**
             * Deduplicate collision features by DR number
             * Returns array of unique features
             */
            deduplicateFeatures(features) {
                const uniqueMap = new Map();
                features.forEach(feature => {
                    const dr = feature.properties.dr_number;
                    if (dr && !uniqueMap.has(dr)) {
                        uniqueMap.set(dr, feature);
                    }
                });
                return Array.from(uniqueMap.values());
            }

            /**
             * Format tooltip HTML for multiple collisions at same location
             * Shows inline list of all incidents
             */
            formatTooltipHTMLForMultiple(features) {
                if (features.length === 1) {
                    // Single collision - use existing formatter
                    return this.formatTooltipHTML(features[0].properties);
                }

                // Limit to first 10 for performance
                const displayFeatures = features.slice(0, 10);
                const hasMore = features.length > 10;

                // Format each collision as a compact line
                const incidentLines = displayFeatures.map(feature => {
                    const props = feature.properties;
                    const dateStr = props.date_occ ? props.date_occ.split('T')[0] : '?';
                    const timeStr = this.formatTime(props.time_occ_minutes);
                    const severity = props.severity || 'unknown';

                    // Severity badge color
                    const color = {
                        'property_damage': '#6c757d',
                        'minor_injury': '#ffc107',
                        'severe_injury': '#fd7e14',
                        'fatal': '#dc3545'
                    }[severity] || '#6c757d';

                    // Severity abbreviation
                    const sevAbbrev = {
                        'property_damage': 'PDO',
                        'minor_injury': 'MIN',
                        'severe_injury': 'SEV',
                        'fatal': 'FAT'
                    }[severity] || '???';

                    return `<div style="display: flex; gap: 6px; align-items: center; padding: 2px 0; font-size: 11px;">
                        <span style="background: ${color}; color: #fff; padding: 1px 4px; border-radius: 2px; font-weight: 600; min-width: 32px; text-align: center;">${sevAbbrev}</span>
                        <span style="color: #ddd;">${dateStr}</span>
                        <span style="color: #bbb;">${timeStr}</span>
                    </div>`;
                }).join('');

                return `
                    <div class="tooltip-header">
                        <div class="tooltip-title">${features[0].properties.area_name || 'Unknown Area'}</div>
                        <div class="tooltip-severity" style="background-color: #4a90d9; font-size: 11px;">
                            ${features.length} Collisions
                        </div>
                    </div>
                    <div class="tooltip-body" style="padding: 8px; max-height: 300px; overflow-y: auto;">
                        <div style="margin-bottom: 6px; font-size: 11px; color: #999; font-weight: 600;">
                            Location: ${features[0].properties.address || 'Unknown'}
                        </div>
                        ${incidentLines}
                        ${hasMore ? `<div style="margin-top: 6px; font-size: 11px; color: #999; font-style: italic;">...and ${features.length - 10} more</div>` : ''}
                    </div>
                `;
            }

            /**
             * Format collision properties into compact HTML for hover tooltip
             * Shows key fields for quick preview and debugging
             */
            formatTooltipHTML(props) {
                // Format time
                const timeStr = this.formatTime(props.time_occ_minutes);

                // Format date (just the date part, no time)
                const dateStr = props.date_occ ? props.date_occ.split('T')[0] : 'Unknown';

                // Format collision type (capitalize words)
                const collisionType = props.collision_type
                    ? props.collision_type.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ')
                    : 'Unknown';

                // Format severity (capitalize, replace underscores)
                const severity = props.severity
                    ? props.severity.split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ')
                    : 'Unknown';

                // Severity badge color
                const severityColors = {
                    'property_damage': '#6c757d',  // Gray
                    'minor_injury': '#ffc107',     // Yellow
                    'severe_injury': '#fd7e14',    // Orange
                    'fatal': '#dc3545'             // Red
                };
                const severityColor = severityColors[props.severity] || '#6c757d';

                // Build HTML
                return `
                    <div class="tooltip-header">
                        <div class="tooltip-title">${props.area_name || 'Unknown Area'}</div>
                        <div class="tooltip-severity" style="background-color: ${severityColor}">
                            ${severity}
                        </div>
                    </div>
                    <div class="tooltip-body">
                        <div class="tooltip-row">
                            <span class="tooltip-label">Date:</span>
                            <span class="tooltip-value">${dateStr}</span>
                        </div>
                        <div class="tooltip-row">
                            <span class="tooltip-label">Time:</span>
                            <span class="tooltip-value">${timeStr}</span>
                        </div>
                        <div class="tooltip-row">
                            <span class="tooltip-label">Type:</span>
                            <span class="tooltip-value">${collisionType}</span>
                        </div>
                        <div class="tooltip-row">
                            <span class="tooltip-label">Location:</span>
                            <span class="tooltip-value">${props.address || 'Unknown'}</span>
                        </div>
                        ${props.cross_street ? `
                        <div class="tooltip-row">
                            <span class="tooltip-label">Cross St:</span>
                            <span class="tooltip-value">${props.cross_street}</span>
                        </div>
                        ` : ''}
                        ${props.is_hit_and_run ? '<div class="tooltip-badge hit-run">Hit & Run</div>' : ''}
                        ${props.is_dui ? '<div class="tooltip-badge dui">DUI-Related</div>' : ''}
                    </div>
                    <div class="tooltip-footer">
                        <span class="tooltip-hint">Click for full details</span>
                    </div>
                    <div class="tooltip-debug">
                        <details>
                            <summary>Debug Info</summary>
                            <div class="debug-content">
                                <div>DR: ${props.dr_number || 'N/A'}</div>
                                <div>Bucket: ${props.time_bucket || 'N/A'}</div>
                                <div>Hour: ${props.hour !== null ? props.hour : 'N/A'}</div>
                                <div>Weekend: ${props.is_weekend ? 'Yes' : 'No'}</div>
                                <div>MO Codes: ${props.mo_codes || 'None'}</div>
                            </div>
                        </details>
                    </div>
                `;
            }

            /**
             * Update data table with visible collisions
             * Called after map updates or filters change
             */
            updateDataTable(filteredData) {
                // Store full dataset for export
                this.currentFilteredData = filteredData;

                // Update count
                document.getElementById('tableCount').textContent =
                    `${filteredData.length.toLocaleString()} collision${filteredData.length === 1 ? '' : 's'}`;

                // LIMIT TO FIRST 100 ROWS for performance
                const displayLimit = 100;
                const displayData = filteredData.slice(0, displayLimit);
                const hasMore = filteredData.length > displayLimit;

                // Populate table body
                const tbody = document.getElementById('tableBody');
                tbody.innerHTML = displayData.map(feature => {
                    const props = feature.properties;
                    const timeStr = this.formatTime(props.time_occ_minutes);
                    const dateStr = props.date_occ ? props.date_occ.split('T')[0] : 'Unknown';
                    const severity = props.severity || 'unknown';
                    const severityLabel = severity.split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join(' ');

                    // Format collision type
                    const collisionType = props.collision_type || 'unknown';
                    const collisionTypeLabel = collisionType.split('-').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join('-');

                    return `
                        <tr data-dr-number="${props.dr_number}" data-coords="${feature.geometry.coordinates.join(',')}">
                            <td>${dateStr}</td>
                            <td>${timeStr}</td>
                            <td><span class="severity-badge severity-${severity}">${severityLabel}</span></td>
                            <td style="font-size: 0.8rem;">${collisionTypeLabel}</td>
                            <td>${props.address || 'Unknown'}</td>
                        </tr>
                    `;
                }).join('');

                // Show/hide "Load More" indicator
                const loadMoreIndicator = document.getElementById('tableLoadMore');
                if (loadMoreIndicator) {
                    if (hasMore) {
                        loadMoreIndicator.style.display = 'block';
                        loadMoreIndicator.textContent = `Showing first ${displayLimit} of ${filteredData.length.toLocaleString()} collisions`;
                    } else {
                        loadMoreIndicator.style.display = 'none';
                    }
                }

                // Add click handlers using EVENT DELEGATION
                this.attachTableRowHandlers();
            }

            /**
             * Attach table row click handlers using event delegation
             * O(1) instead of O(n) - single listener on tbody
             */
            attachTableRowHandlers() {
                const tbody = document.getElementById('tableBody');

                // Remove old listener if exists
                if (this.tableClickHandler) {
                    tbody.removeEventListener('click', this.tableClickHandler);
                }

                // Create new handler with event delegation
                this.tableClickHandler = (e) => {
                    const row = e.target.closest('tr');
                    if (!row || !row.dataset.coords) return;

                    const coords = row.dataset.coords.split(',').map(Number);
                    const drNumber = row.dataset.drNumber;

                    // Highlight this row
                    this.highlightTableRow(drNumber);

                    // Find and highlight corresponding map point
                    const features = this.map.querySourceFeatures('collisions');
                    const matchingFeature = features.find(
                        f => f.properties && f.properties.dr_number === drNumber
                    );

                    if (matchingFeature) {
                        // Remove previous highlight
                        if (this.selectedCollisionId) {
                            this.map.setFeatureState(
                                { source: 'collisions', id: this.selectedCollisionId },
                                { selected: false }
                            );
                        }

                        // Add new highlight
                        this.selectedCollisionId = matchingFeature.id;
                        this.map.setFeatureState(
                            { source: 'collisions', id: matchingFeature.id },
                            { selected: true }
                        );
                    }

                    // Fly to location on map
                    this.map.flyTo({
                        center: coords,
                        zoom: Math.max(this.map.getZoom(), 16),
                        duration: 1000
                    });
                };

                tbody.addEventListener('click', this.tableClickHandler);
            }

            /**
             * Export visible collision data as CSV
             */
            exportToCSV(filteredData) {
                // CSV headers
                const headers = [
                    'DR Number',
                    'Date',
                    'Time',
                    'Area',
                    'Collision Type',
                    'Severity',
                    'Location',
                    'Cross Street',
                    'Hit and Run',
                    'DUI Related',
                    'Latitude',
                    'Longitude'
                ];

                // CSV rows
                const rows = filteredData.map(feature => {
                    const props = feature.properties;
                    const coords = feature.geometry.coordinates;
                    const timeStr = this.formatTime(props.time_occ_minutes);
                    const dateStr = props.date_occ ? props.date_occ.split('T')[0] : '';

                    return [
                        props.dr_number || '',
                        dateStr,
                        timeStr,
                        props.area_name || '',
                        props.collision_type || '',
                        props.severity || '',
                        props.address || '',
                        props.cross_street || '',
                        props.is_hit_and_run ? 'Yes' : 'No',
                        props.is_dui ? 'Yes' : 'No',
                        coords[1],  // latitude
                        coords[0]   // longitude
                    ].map(val => `"${String(val).replace(/"/g, '""')}"`).join(',');
                });

                // Combine
                const csv = [headers.join(','), ...rows].join('\n');

                // Download
                const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `la-collisions-${new Date().toISOString().split('T')[0]}.csv`;
                link.click();
            }

            /**
             * Setup table sorting functionality
             */
            setupTableSorting() {
                let currentSort = { column: 'date_occ', direction: 'desc' };

                document.querySelectorAll('.collisions-table th[data-sort]').forEach(th => {
                    th.addEventListener('click', () => {
                        const column = th.dataset.sort;

                        // Toggle direction if same column, otherwise default to asc
                        if (currentSort.column === column) {
                            currentSort.direction = currentSort.direction === 'asc' ? 'desc' : 'asc';
                        } else {
                            currentSort = { column, direction: 'asc' };
                        }

                        // Update UI
                        document.querySelectorAll('.collisions-table th').forEach(h => {
                            h.classList.remove('sorted-asc', 'sorted-desc');
                        });
                        th.classList.add(`sorted-${currentSort.direction}`);

                        // Sort the table data
                        this.sortTable(currentSort.column, currentSort.direction);
                    });
                });
            }

            sortTable(column, direction) {
                const tbody = document.getElementById('tableBody');
                const rows = Array.from(tbody.querySelectorAll('tr'));

                rows.sort((a, b) => {
                    const aVal = a.children[this.getColumnIndex(column)].textContent;
                    const bVal = b.children[this.getColumnIndex(column)].textContent;

                    const comparison = aVal.localeCompare(bVal, undefined, { numeric: true });
                    return direction === 'asc' ? comparison : -comparison;
                });

                tbody.innerHTML = '';
                rows.forEach(row => tbody.appendChild(row));
            }

            getColumnIndex(column) {
                const columnMap = {
                    'date_occ': 0,
                    'time_occ_minutes': 1,
                    'severity': 2,
                    'collision_type': 3,
                    'address': 4
                };
                return columnMap[column] || 0;
            }

            debounce(func, wait) {
                let timeout;
                return (...args) => {
                    clearTimeout(timeout);
                    timeout = setTimeout(() => func.apply(this, args), wait);
                };
            }

            setupMobileNav() {
                const navToggle = document.querySelector('.nav-toggle');
                const navLinks = document.querySelector('.nav-links');

                if (navToggle && navLinks) {
                    navToggle.addEventListener('click', () => {
                        const isExpanded = navToggle.getAttribute('aria-expanded') === 'true';
                        navToggle.setAttribute('aria-expanded', !isExpanded);
                        navLinks.classList.toggle('active');
                    });
                }
            }
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', () => {
            new LACollisionDashboard();
        });
    </script>
</body>
</html>
