<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D Blob Prototype - Morphing Asteroid</title>

  <!-- Google Fonts: Silkscreen, Audiowide, IBM Plex Mono -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Silkscreen:wght@400;700&family=Audiowide&family=IBM+Plex+Mono:wght@400;500;600&display=swap" rel="stylesheet">

  <style>
    :root {
      --color-space-black: #000000;
      --color-bright-purple: #DA00FF;
      --color-neon-cyan: #00FFFF;
      --color-hot-magenta: #FF00FF;
      --color-acid-green: #39FF14;
      --color-electric-blue: #00BFFF;
      --current-blob-color: #DA00FF;
    }

    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'IBM Plex Mono', monospace;
      background: var(--color-space-black);
      color: white;
      overflow-x: hidden;
      overflow-y: scroll;
    }

    /* Fixed starfield background */
    #starfield {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 0;
      pointer-events: none;
    }

    /* Fixed blob viewport */
    #blob-viewport {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      z-index: 10;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
    }

    #blob-canvas {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
      will-change: transform;
    }

    #blob-content-container {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 90%;
      max-width: 600px;
      text-align: center;
      pointer-events: all;
      z-index: 20;
      will-change: contents;
      isolation: isolate;
    }

    .blob-content {
      opacity: 0;
      transform: scale(1);
      transition: opacity 0.5s ease, transform 0.5s ease;
      display: none;
    }

    .blob-content.active {
      opacity: 1;
      display: block;
    }

    /* Typography */
    h1, h2 {
      font-family: 'Silkscreen', 'Courier New', monospace;
      text-shadow:
        0 0 10px var(--current-blob-color),
        0 0 20px var(--current-blob-color),
        0 0 30px var(--current-blob-color),
        0 0 40px rgba(255, 255, 255, 0.5);
      letter-spacing: 1px;
      color: var(--current-blob-color);
      margin-bottom: 1rem;
    }

    h1 {
      font-size: 2.5rem;
      font-weight: 700;
    }

    h2 {
      font-size: 2rem;
      font-weight: 400;
    }

    h3 {
      font-family: 'Audiowide', cursive;
      text-shadow:
        0 0 10px var(--current-blob-color),
        0 0 20px var(--current-blob-color),
        0 0 30px var(--current-blob-color),
        0 0 40px rgba(255, 255, 255, 0.5);
      letter-spacing: 1px;
      color: var(--current-blob-color);
      margin-bottom: 1rem;
      font-size: 1.5rem;
      font-weight: 400;
    }

    p {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 1rem;
      line-height: 1.7;
      margin-bottom: 1.5rem;
      color: rgba(255, 255, 255, 0.9);
      font-weight: 400;
    }

    .blob-subtitle {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 1.1rem;
      color: rgba(255, 255, 255, 0.7);
      margin-bottom: 2rem;
      font-weight: 400;
    }

    .blob-description {
      font-family: 'IBM Plex Mono', monospace;
      font-weight: 400;
    }

    /* Glass-morphism buttons */
    .blob-actions {
      display: flex;
      gap: 1rem;
      justify-content: center;
      flex-wrap: wrap;
      margin-top: 2rem;
    }

    .blob-btn {
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      padding: 16px 32px;
      color: white;
      font-weight: 600;
      font-size: 1rem;
      letter-spacing: 0.5px;
      cursor: pointer;
      transition: all 0.3s ease;
      text-decoration: none;
      display: inline-block;
      will-change: transform, background;
      transform: translateZ(0);
      backface-visibility: hidden;
    }

    .blob-btn:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: scale(1.05);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
    }

    .blob-btn-primary {
      background: rgba(139, 0, 255, 0.3);
      border-color: var(--current-blob-color);
    }

    .blob-btn-primary:hover {
      background: rgba(139, 0, 255, 0.5);
    }

    /* Tags */
    .blob-tags {
      display: flex;
      gap: 0.5rem;
      justify-content: center;
      flex-wrap: wrap;
      margin-bottom: 1.5rem;
    }

    .tag {
      background: rgba(255, 255, 255, 0.1);
      padding: 6px 12px;
      border-radius: 6px;
      font-size: 0.85rem;
      letter-spacing: 0.5px;
      border: 1px solid rgba(255, 255, 255, 0.15);
    }

    /* Scroll spacer */
    #scroll-spacer {
      height: 200vh;
      position: relative;
      z-index: 5;
    }

    /* Scroll indicator */
    #scroll-indicator {
      position: fixed;
      right: 24px;
      top: 50%;
      transform: translateY(-50%);
      z-index: 100;
      display: flex;
      flex-direction: column;
      gap: 12px;
      pointer-events: all;
    }

    .scroll-dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
      background: rgba(255, 255, 255, 0.2);
      border: 2px solid rgba(255, 255, 255, 0.3);
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .scroll-dot.active {
      background: var(--current-blob-color);
      border-color: var(--current-blob-color);
      box-shadow: 0 0 10px var(--current-blob-color), 0 0 20px var(--current-blob-color);
      transform: scale(1.3);
    }

    .scroll-dot:hover {
      background: rgba(255, 255, 255, 0.4);
      transform: scale(1.2);
    }

    /* Mobile responsive */
    @media (max-width: 768px) {
      h1 {
        font-size: 2rem;
      }

      h2 {
        font-size: 1.5rem;
      }

      p {
        font-size: 1rem;
      }

      .blob-actions {
        flex-direction: column;
      }

      .blob-btn {
        width: 100%;
      }
    }

    /* Reduced motion fallback */
    @media (prefers-reduced-motion: reduce) {
      #blob-canvas {
        display: none;
      }

      #blob-viewport {
        background: linear-gradient(135deg, #1a0033 0%, #000033 100%);
      }
    }

    /* Control Panel */
    .blob-controls {
      position: fixed;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 90%;
      max-width: 600px;
      z-index: 200;
      transition: transform 0.3s ease;
    }

    .controls-header {
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-radius: 12px 12px 0 0;
      padding: 12px 24px;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 12px;
      transition: background 0.3s ease;
    }

    .controls-header:hover {
      background: rgba(0, 0, 0, 0.9);
      border-color: rgba(255, 255, 255, 0.2);
    }

    .controls-caret {
      font-size: 1rem;
      transition: transform 0.3s ease;
      color: white;
      text-shadow: none;
    }

    .blob-controls.open .controls-caret {
      transform: rotate(180deg);
    }

    .controls-title {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.9rem;
      font-weight: 500;
      letter-spacing: 0.5px;
      color: rgba(255, 255, 255, 0.9);
      display: none;
    }

    #grid-resolution-control {
      display: none;
    }

    .controls-drawer {
      background: rgba(0, 0, 0, 0.9);
      backdrop-filter: blur(20px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      border-top: none;
      border-radius: 0 0 12px 12px;
      padding: 0 24px;
      max-height: 0;
      overflow: hidden;
      opacity: 0;
      transition: max-height 0.3s ease, opacity 0.3s ease, padding 0.3s ease;
    }

    .blob-controls.open .controls-drawer {
      max-height: 500px;
      opacity: 1;
      padding: 24px;
    }

    .controls-grid {
      display: flex;
      flex-direction: column;
      gap: 16px;
    }

    .control-item {
      display: grid;
      grid-template-columns: 140px 1fr 60px;
      gap: 12px;
      align-items: center;
    }

    .control-item label {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.85rem;
      color: rgba(255, 255, 255, 0.8);
      font-weight: 500;
    }

    .control-value {
      font-family: 'IBM Plex Mono', monospace;
      font-size: 0.85rem;
      color: white;
      text-align: right;
      font-weight: 600;
      text-shadow: none;
    }

    /* Custom slider styling */
    input[type="range"] {
      -webkit-appearance: none;
      appearance: none;
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: rgba(255, 255, 255, 0.1);
      outline: none;
      transition: background 0.2s ease;
    }

    input[type="range"]:hover {
      background: rgba(255, 255, 255, 0.15);
    }

    /* Webkit browsers (Chrome, Safari) */
    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: white;
      cursor: pointer;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.2);
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.7);
    }

    /* Firefox */
    input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: white;
      cursor: pointer;
      border: none;
      box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
      transition: transform 0.2s ease, box-shadow 0.2s ease;
    }

    input[type="range"]::-moz-range-thumb:hover {
      transform: scale(1.2);
      box-shadow: 0 0 15px rgba(255, 255, 255, 0.7);
    }

    .controls-reset {
      margin-top: 16px;
      width: 100%;
      background: rgba(255, 255, 255, 0.1);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 8px;
      padding: 12px 24px;
      color: white;
      font-family: 'IBM Plex Mono', monospace;
      font-weight: 600;
      font-size: 0.9rem;
      letter-spacing: 0.5px;
      cursor: pointer;
      transition: all 0.3s ease;
    }

    .controls-reset:hover {
      background: rgba(255, 255, 255, 0.2);
      transform: scale(1.02);
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
    }

    /* Mobile responsive */
    @media (max-width: 768px) {
      .blob-controls {
        width: 100%;
        max-width: none;
        left: 0;
        right: 0;
        bottom: 0;
        transform: none;
      }

      .blob-controls.open .controls-drawer {
        max-height: 450px;
        overflow-y: auto;
      }

      .control-item {
        grid-template-columns: 120px 1fr 50px;
        gap: 8px;
      }

      .control-item label {
        font-size: 0.8rem;
      }

      .control-value {
        font-size: 0.8rem;
      }
    }
  </style>
</head>
<body>
  <!-- Starfield canvas (fixed) -->
  <canvas id="starfield"></canvas>

  <!-- Blob viewport (fixed, centered) -->
  <div id="blob-viewport">
    <canvas id="blob-canvas"></canvas>
    <div id="blob-content-container">
      <!-- Section 0: Hero -->
      <div class="blob-content active" data-section="0">
        <h1 class="blob-title">Simone Longo</h1>
        <p class="blob-subtitle">Software Engineer</p>
        <div class="blob-actions">
          <button class="blob-btn" onclick="scrollToSection(1)">Projects</button>
          <button class="blob-btn" onclick="scrollToSection(1)">About</button>
          <button class="blob-btn" onclick="scrollToSection(1)">Contact</button>
        </div>
      </div>

      <!-- Section 1: Example Project -->
      <div class="blob-content" data-section="1">
        <h2 class="blob-title">LA Traffic Collisions Dashboard</h2>
        <p class="blob-description">Interactive visualization of 620K+ LAPD collision records with progressive tile-based loading and spatial analysis.</p>
        <div class="blob-tags">
          <span class="tag">MapLibre GL</span>
          <span class="tag">Chart.js</span>
          <span class="tag">RBush</span>
          <span class="tag">Spatial Data</span>
        </div>
        <a href="#" class="blob-btn blob-btn-primary">View Project</a>
      </div>
    </div>
  </div>

  <!-- Scroll indicator -->
  <div id="scroll-indicator">
    <div class="scroll-dot active" data-section="0" title="Hero"></div>
    <div class="scroll-dot" data-section="1" title="LA Collisions"></div>
  </div>

  <!-- Scroll spacer (200vh for 2 sections) -->
  <div id="scroll-spacer"></div>

  <!-- Control Panel -->
  <div id="blob-control-panel" class="blob-controls">
    <div class="controls-header" id="controls-toggle">
      <span class="controls-caret">â–²</span>
      <span class="controls-title">Blob Controls</span>
    </div>
    <div class="controls-drawer">
      <div class="controls-grid">
        <div class="control-item" id="grid-resolution-control">
          <label for="grid-resolution">Grid Resolution</label>
          <input type="range" id="grid-resolution" min="10" max="60" step="2" value="50">
          <span class="control-value" id="grid-resolution-value">50</span>
        </div>
        <div class="control-item">
          <label for="morph-speed">Morph Speed</label>
          <input type="range" id="morph-speed" min="0" max="0.02" step="0.001" value="0.005">
          <span class="control-value" id="morph-speed-value">0.005</span>
        </div>
        <div class="control-item">
          <label for="rotation-speed">Rotation Speed</label>
          <input type="range" id="rotation-speed" min="0" max="0.003" step="0.0001" value="0.0005">
          <span class="control-value" id="rotation-speed-value">0.0005</span>
        </div>
        <div class="control-item">
          <label for="noise-amplitude">Noise Amount</label>
          <input type="range" id="noise-amplitude" min="0" max="0.5" step="0.01" value="0.15">
          <span class="control-value" id="noise-amplitude-value">0.15</span>
        </div>
        <div class="control-item">
          <label for="noise-frequency">Noise Detail</label>
          <input type="range" id="noise-frequency" min="0.001" max="0.01" step="0.0001" value="0.003">
          <span class="control-value" id="noise-frequency-value">0.003</span>
        </div>
        <div class="control-item">
          <label for="base-radius">Size</label>
          <input type="range" id="base-radius" min="100" max="400" step="10" value="250">
          <span class="control-value" id="base-radius-value">250px</span>
        </div>
        <div class="control-item">
          <label for="brightness">Brightness</label>
          <input type="range" id="brightness" min="0.3" max="1.5" step="0.05" value="1.0">
          <span class="control-value" id="brightness-value">1.00</span>
        </div>
        <div class="control-item">
          <label for="line-width">Line Width</label>
          <input type="range" id="line-width" min="0.1" max="3" step="0.1" value="0.5">
          <span class="control-value" id="line-width-value">0.5</span>
        </div>
        <div class="control-item">
          <label for="line-opacity">Line Opacity</label>
          <input type="range" id="line-opacity" min="0.05" max="0.5" step="0.01" value="0.15">
          <span class="control-value" id="line-opacity-value">0.15</span>
        </div>
      </div>
      <button class="controls-reset" id="controls-reset">Reset to Defaults</button>
    </div>
  </div>

  <script>
    // ==========================================
    // CONFIGURATION
    // ==========================================
    const CONFIG = {
      // Blob parameters
      gridResolution: { lat: 50, lon: 50 },
      gridResolutionMobile: { lat: 35, lon: 35 },
      noiseAmplitude: 0.15,
      noiseFrequency: 0.003,
      idleRotationSpeed: { x: 0.0003, y: 0.0005, z: 0.0002 }, // Slower idle rotation
      scrollRotationSpeed: 0.008, // Rotation speed based on scroll (increased for more dramatic effect)
      baseRadius: 250,
      expandedRadius: 250,
      contractedRadius: 5,
      morphSpeed: 0.005,
      brightnessMultiplier: 1.0,
      lineWidth: 0.5,
      baseOpacity: 0.15,

      // Colors
      colors: [
        '#DA00FF', // Bright Purple
        '#00FFFF', // Neon Cyan
        '#FF00FF', // Hot Magenta
        '#39FF14', // Acid Green
        '#00BFFF', // Electric Blue
      ],

      // Starfield
      starCount: 250,

      // Performance
      targetFPS: 60,
      targetFPSMobile: 30,
    };

    // Store default values for reset functionality
    const DEFAULT_CONFIG = {
      gridResolution: { lat: 50, lon: 50 },
      noiseAmplitude: 0.15,
      noiseFrequency: 0.003,
      idleRotationSpeed: { x: 0.0003, y: 0.0005, z: 0.0002 },
      baseRadius: 250,
      morphSpeed: 0.005,
      brightnessMultiplier: 1.0,
      lineWidth: 0.5,
      baseOpacity: 0.15,
    };

    const isMobile = window.innerWidth < 768;
    const targetFPS = isMobile ? CONFIG.targetFPSMobile : CONFIG.targetFPS;
    const frameInterval = 1000 / targetFPS;

    // ==========================================
    // SIMPLEX NOISE (Inline Implementation)
    // ==========================================
    class SimplexNoise {
      constructor() {
        this.grad3 = [
          [1,1,0],[-1,1,0],[1,-1,0],[-1,-1,0],
          [1,0,1],[-1,0,1],[1,0,-1],[-1,0,-1],
          [0,1,1],[0,-1,1],[0,1,-1],[0,-1,-1]
        ];
        this.p = [];
        for (let i = 0; i < 256; i++) {
          this.p[i] = Math.floor(Math.random() * 256);
        }
        this.perm = [];
        for (let i = 0; i < 512; i++) {
          this.perm[i] = this.p[i & 255];
        }
      }

      dot(g, x, y, z) {
        return g[0] * x + g[1] * y + g[2] * z;
      }

      noise3D(x, y, z) {
        const F3 = 1.0 / 3.0;
        const G3 = 1.0 / 6.0;

        let n0, n1, n2, n3;

        const s = (x + y + z) * F3;
        const i = Math.floor(x + s);
        const j = Math.floor(y + s);
        const k = Math.floor(z + s);

        const t = (i + j + k) * G3;
        const X0 = i - t;
        const Y0 = j - t;
        const Z0 = k - t;
        const x0 = x - X0;
        const y0 = y - Y0;
        const z0 = z - Z0;

        let i1, j1, k1, i2, j2, k2;
        if (x0 >= y0) {
          if (y0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }
          else if (x0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }
          else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }
        } else {
          if (y0 < z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }
          else if (x0 < z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }
          else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }
        }

        const x1 = x0 - i1 + G3;
        const y1 = y0 - j1 + G3;
        const z1 = z0 - k1 + G3;
        const x2 = x0 - i2 + 2.0 * G3;
        const y2 = y0 - j2 + 2.0 * G3;
        const z2 = z0 - k2 + 2.0 * G3;
        const x3 = x0 - 1.0 + 3.0 * G3;
        const y3 = y0 - 1.0 + 3.0 * G3;
        const z3 = z0 - 1.0 + 3.0 * G3;

        const ii = i & 255;
        const jj = j & 255;
        const kk = k & 255;
        const gi0 = this.perm[ii + this.perm[jj + this.perm[kk]]] % 12;
        const gi1 = this.perm[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]] % 12;
        const gi2 = this.perm[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]] % 12;
        const gi3 = this.perm[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]] % 12;

        let t0 = 0.6 - x0*x0 - y0*y0 - z0*z0;
        if (t0 < 0) n0 = 0.0;
        else {
          t0 *= t0;
          n0 = t0 * t0 * this.dot(this.grad3[gi0], x0, y0, z0);
        }

        let t1 = 0.6 - x1*x1 - y1*y1 - z1*z1;
        if (t1 < 0) n1 = 0.0;
        else {
          t1 *= t1;
          n1 = t1 * t1 * this.dot(this.grad3[gi1], x1, y1, z1);
        }

        let t2 = 0.6 - x2*x2 - y2*y2 - z2*z2;
        if (t2 < 0) n2 = 0.0;
        else {
          t2 *= t2;
          n2 = t2 * t2 * this.dot(this.grad3[gi2], x2, y2, z2);
        }

        let t3 = 0.6 - x3*x3 - y3*y3 - z3*z3;
        if (t3 < 0) n3 = 0.0;
        else {
          t3 *= t3;
          n3 = t3 * t3 * this.dot(this.grad3[gi3], x3, y3, z3);
        }

        return 32.0 * (n0 + n1 + n2 + n3);
      }
    }

    const simplex = new SimplexNoise();

    // ==========================================
    // COLOR UTILITIES
    // ==========================================
    function hexToRgb(hex) {
      const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
      return result ? {
        r: parseInt(result[1], 16),
        g: parseInt(result[2], 16),
        b: parseInt(result[3], 16)
      } : null;
    }

    function rgbToHsl(r, g, b) {
      r /= 255;
      g /= 255;
      b /= 255;
      const max = Math.max(r, g, b);
      const min = Math.min(r, g, b);
      let h, s, l = (max + min) / 2;

      if (max === min) {
        h = s = 0;
      } else {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
          case r: h = ((g - b) / d + (g < b ? 6 : 0)) / 6; break;
          case g: h = ((b - r) / d + 2) / 6; break;
          case b: h = ((r - g) / d + 4) / 6; break;
        }
      }

      return { h, s, l };
    }

    function hslToRgb(h, s, l) {
      let r, g, b;

      if (s === 0) {
        r = g = b = l;
      } else {
        const hue2rgb = (p, q, t) => {
          if (t < 0) t += 1;
          if (t > 1) t -= 1;
          if (t < 1/6) return p + (q - p) * 6 * t;
          if (t < 1/2) return q;
          if (t < 2/3) return p + (q - p) * (2/3 - t) * 6;
          return p;
        };

        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hue2rgb(p, q, h + 1/3);
        g = hue2rgb(p, q, h);
        b = hue2rgb(p, q, h - 1/3);
      }

      return {
        r: Math.round(r * 255),
        g: Math.round(g * 255),
        b: Math.round(b * 255)
      };
    }

    function rgbToHex(r, g, b) {
      return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
    }

    function adjustBrightness(hexColor, multiplier) {
      const rgb = hexToRgb(hexColor);
      if (!rgb) return hexColor;

      const hsl = rgbToHsl(rgb.r, rgb.g, rgb.b);
      hsl.l = Math.min(1, Math.max(0, hsl.l * multiplier));

      const newRgb = hslToRgb(hsl.h, hsl.s, hsl.l);
      return rgbToHex(newRgb.r, newRgb.g, newRgb.b);
    }

    // ==========================================
    // STARFIELD
    // ==========================================
    const starfieldCanvas = document.getElementById('starfield');
    const starfieldCtx = starfieldCanvas.getContext('2d');

    function resizeStarfield() {
      starfieldCanvas.width = window.innerWidth;
      starfieldCanvas.height = window.innerHeight;
    }
    resizeStarfield();
    window.addEventListener('resize', resizeStarfield);

    // Generate stars
    const stars = [];
    for (let i = 0; i < CONFIG.starCount; i++) {
      stars.push({
        x: Math.random() * starfieldCanvas.width,
        y: Math.random() * starfieldCanvas.height,
        radius: Math.random() * 1.5 + 0.5,
        opacity: Math.random() * 0.5 + 0.5,
        twinkleSpeed: Math.random() * 0.02 + 0.01,
        twinklePhase: Math.random() * Math.PI * 2,
      });
    }

    function renderStarfield(time) {
      starfieldCtx.fillStyle = '#000000';
      starfieldCtx.fillRect(0, 0, starfieldCanvas.width, starfieldCanvas.height);

      stars.forEach(star => {
        const twinkle = Math.sin(time * star.twinkleSpeed + star.twinklePhase);
        const opacity = star.opacity + twinkle * 0.3;

        starfieldCtx.beginPath();
        starfieldCtx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
        starfieldCtx.fillStyle = `rgba(255, 255, 255, ${opacity})`;
        starfieldCtx.fill();
      });
    }

    // ==========================================
    // 3D BLOB MESH
    // ==========================================
    const blobCanvas = document.getElementById('blob-canvas');
    const blobCtx = blobCanvas.getContext('2d');

    function resizeBlob() {
      // Make canvas full viewport size for better coverage
      blobCanvas.width = window.innerWidth;
      blobCanvas.height = window.innerHeight;
    }
    resizeBlob();
    window.addEventListener('resize', resizeBlob);

    // Generate 3D sphere mesh
    const gridRes = CONFIG.gridResolution;
    const vertices = [];

    for (let lat = 0; lat <= gridRes.lat; lat++) {
      for (let lon = 0; lon <= gridRes.lon; lon++) {
        const theta = (lat / gridRes.lat) * Math.PI;
        const phi = (lon / gridRes.lon) * Math.PI * 2;

        vertices.push({
          lat,
          lon,
          theta,
          phi,
          x: 0,
          y: 0,
          z: 0,
          projected: { x: 0, y: 0 },
        });
      }
    }

    // Rotation state
    let rotation = { x: 0, y: 0, z: 0 };

    // ==========================================
    // 3D TRANSFORMATIONS
    // ==========================================
    function rotateX(x, y, z, angle) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      return {
        x,
        y: y * cos - z * sin,
        z: y * sin + z * cos,
      };
    }

    function rotateY(x, y, z, angle) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      return {
        x: x * cos + z * sin,
        y,
        z: -x * sin + z * cos,
      };
    }

    function rotateZ(x, y, z, angle) {
      const cos = Math.cos(angle);
      const sin = Math.sin(angle);
      return {
        x: x * cos - y * sin,
        y: x * sin + y * cos,
        z,
      };
    }

    function project3D(x, y, z, radius) {
      const perspective = 600;
      const scale = perspective / (perspective + z);
      return {
        x: blobCanvas.width / 2 + x * scale,
        y: blobCanvas.height / 2 + y * scale,
        scale,
      };
    }

    // ==========================================
    // SCROLL HANDLING
    // ==========================================
    let currentSection = 0;
    let currentRadius = CONFIG.expandedRadius;
    let currentColor = CONFIG.colors[0];
    let isScrolling = false;
    let scrollTimeout;
    let lastScrollY = 0;
    let scrollRotation = 0;

    function updateScroll() {
      const scrollY = window.scrollY;
      const sectionHeight = window.innerHeight;
      const maxScroll = sectionHeight;

      // Detect scrolling
      isScrolling = true;
      clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(() => {
        isScrolling = false;
      }, 150);

      // Track scroll-based rotation
      const scrollDelta = scrollY - lastScrollY;
      scrollRotation += scrollDelta * CONFIG.scrollRotationSpeed;
      lastScrollY = scrollY;

      const section = Math.floor(scrollY / sectionHeight);
      const progress = (scrollY % sectionHeight) / sectionHeight;

      currentSection = Math.min(section, 1);

      // Update radius (expand/contract)
      if (progress < 0.5) {
        currentRadius = CONFIG.expandedRadius * (1 - progress * 2) + CONFIG.contractedRadius * (progress * 2);
      } else {
        currentRadius = CONFIG.contractedRadius * (1 - (progress - 0.5) * 2) + CONFIG.expandedRadius * ((progress - 0.5) * 2);
      }

      // Update content visibility with slower fade/scale
      // Text transitions at 0.35x speed compared to asteroid for more reading time
      const textSpeed = 0.35;

      document.querySelectorAll('.blob-content').forEach((content, index) => {
        if (progress < 0.5 && index === section) {
          content.classList.add('active');
          // Fade out and shrink more slowly
          const textProgress = Math.min(progress * 2 * textSpeed, 1);
          content.style.opacity = 1 - textProgress;
          content.style.transform = `scale(${1 - textProgress * 0.3})`; // Shrink to 70% at minimum
        } else if (progress >= 0.5 && index === section + 1) {
          content.classList.add('active');
          // Fade in and grow more slowly
          const textProgress = Math.min((progress - 0.5) * 2 * textSpeed, 1);
          content.style.opacity = textProgress;
          content.style.transform = `scale(${0.7 + textProgress * 0.3})`; // Grow from 70% to 100%
        } else {
          content.classList.remove('active');
        }
      });

      // Update scroll indicator dots based on which section's content is more visible
      const activeSection = progress < 0.5 ? section : Math.min(section + 1, 1);
      document.querySelectorAll('.scroll-dot').forEach((dot, index) => {
        if (index === activeSection) {
          dot.classList.add('active');
        } else {
          dot.classList.remove('active');
        }
      });

      // Update color only at midpoint (when asteroid is fully collapsed)
      // This keeps each section's color consistent until the transition midpoint
      const colorSection = progress < 0.5 ? section : Math.min(section + 1, 1);
      const colorIndex = colorSection % CONFIG.colors.length;
      currentColor = CONFIG.colors[colorIndex];
      document.documentElement.style.setProperty('--current-blob-color', currentColor);
    }

    window.addEventListener('scroll', updateScroll);
    updateScroll();

    // Scroll indicator click handlers
    document.querySelectorAll('.scroll-dot').forEach(dot => {
      dot.addEventListener('click', () => {
        const section = parseInt(dot.dataset.section);
        window.scrollTo({
          top: section * window.innerHeight,
          behavior: 'smooth',
        });
      });
    });

    function scrollToSection(index) {
      window.scrollTo({
        top: index * window.innerHeight,
        behavior: 'smooth',
      });
    }

    // ==========================================
    // CONTROL PANEL
    // ==========================================
    const controlPanel = document.getElementById('blob-control-panel');
    const toggleBtn = document.getElementById('controls-toggle');
    const resetBtn = document.getElementById('controls-reset');

    // Toggle panel open/closed
    toggleBtn.addEventListener('click', (e) => {
      e.stopPropagation();
      controlPanel.classList.toggle('open');
    });

    // Close panel when clicking outside
    document.addEventListener('click', (e) => {
      if (controlPanel.classList.contains('open') && !controlPanel.contains(e.target)) {
        controlPanel.classList.remove('open');
      }
    });

    // Prevent clicks inside panel from closing it
    controlPanel.addEventListener('click', (e) => {
      e.stopPropagation();
    });

    // Function to regenerate mesh with new grid resolution
    function regenerateBlobMesh() {
      const gridRes = CONFIG.gridResolution;
      vertices.length = 0; // Clear array

      for (let lat = 0; lat <= gridRes.lat; lat++) {
        for (let lon = 0; lon <= gridRes.lon; lon++) {
          const theta = (lat / gridRes.lat) * Math.PI;
          const phi = (lon / gridRes.lon) * Math.PI * 2;

          vertices.push({
            lat,
            lon,
            theta,
            phi,
            x: 0,
            y: 0,
            z: 0,
            projected: { x: 0, y: 0 },
          });
        }
      }
    }

    // Update display value helper
    function updateValueDisplay(sliderId, value, suffix = '') {
      const display = document.getElementById(sliderId + '-value');
      if (display) {
        display.textContent = value + suffix;
      }
    }

    // Grid Resolution slider
    const gridSlider = document.getElementById('grid-resolution');
    gridSlider.addEventListener('input', (e) => {
      const value = parseInt(e.target.value);
      CONFIG.gridResolution = { lat: value, lon: value };
      updateValueDisplay('grid-resolution', value);
      regenerateBlobMesh();
      saveSettings();
    });

    // Morph Speed slider
    const morphSlider = document.getElementById('morph-speed');
    morphSlider.addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      CONFIG.morphSpeed = value;
      updateValueDisplay('morph-speed', value.toFixed(3));
      saveSettings();
    });

    // Rotation Speed slider
    const rotationSlider = document.getElementById('rotation-speed');
    rotationSlider.addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      CONFIG.idleRotationSpeed = {
        x: value * 0.6,
        y: value,
        z: value * 0.4
      };
      updateValueDisplay('rotation-speed', value.toFixed(4));
      saveSettings();
    });

    // Noise Amplitude slider
    const noiseAmpSlider = document.getElementById('noise-amplitude');
    noiseAmpSlider.addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      CONFIG.noiseAmplitude = value;
      updateValueDisplay('noise-amplitude', value.toFixed(2));
      saveSettings();
    });

    // Noise Frequency slider
    const noiseFreqSlider = document.getElementById('noise-frequency');
    noiseFreqSlider.addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      CONFIG.noiseFrequency = value;
      updateValueDisplay('noise-frequency', value.toFixed(4));
      saveSettings();
    });

    // Base Radius slider
    const radiusSlider = document.getElementById('base-radius');
    radiusSlider.addEventListener('input', (e) => {
      const value = parseInt(e.target.value);
      CONFIG.baseRadius = value;
      CONFIG.expandedRadius = value;
      updateValueDisplay('base-radius', value, 'px');
      updateScroll(); // Recalculate currentRadius with new size
      saveSettings();
    });

    // Brightness slider
    const brightnessSlider = document.getElementById('brightness');
    brightnessSlider.addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      CONFIG.brightnessMultiplier = value;
      updateValueDisplay('brightness', value.toFixed(2));
      saveSettings();
    });

    // Line Width slider
    const lineWidthSlider = document.getElementById('line-width');
    lineWidthSlider.addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      CONFIG.lineWidth = value;
      updateValueDisplay('line-width', value.toFixed(1));
      saveSettings();
    });

    // Line Opacity slider
    const lineOpacitySlider = document.getElementById('line-opacity');
    lineOpacitySlider.addEventListener('input', (e) => {
      const value = parseFloat(e.target.value);
      CONFIG.baseOpacity = value;
      updateValueDisplay('line-opacity', value.toFixed(2));
      saveSettings();
    });

    // LocalStorage persistence
    function saveSettings() {
      const settings = {
        gridResolution: CONFIG.gridResolution.lat,
        morphSpeed: CONFIG.morphSpeed,
        rotationSpeed: CONFIG.idleRotationSpeed.y,
        noiseAmplitude: CONFIG.noiseAmplitude,
        noiseFrequency: CONFIG.noiseFrequency,
        baseRadius: CONFIG.baseRadius,
        brightnessMultiplier: CONFIG.brightnessMultiplier,
        lineWidth: CONFIG.lineWidth,
        baseOpacity: CONFIG.baseOpacity
      };
      localStorage.setItem('blobSettings', JSON.stringify(settings));
    }

    function loadSettings() {
      const saved = localStorage.getItem('blobSettings');
      if (saved) {
        try {
          const settings = JSON.parse(saved);

          if (settings.gridResolution) {
            CONFIG.gridResolution = { lat: settings.gridResolution, lon: settings.gridResolution };
            gridSlider.value = settings.gridResolution;
            updateValueDisplay('grid-resolution', settings.gridResolution);
            regenerateBlobMesh();
          }

          if (settings.morphSpeed !== undefined) {
            CONFIG.morphSpeed = settings.morphSpeed;
            morphSlider.value = settings.morphSpeed;
            updateValueDisplay('morph-speed', settings.morphSpeed.toFixed(3));
          }

          if (settings.rotationSpeed !== undefined) {
            const rotSpeed = settings.rotationSpeed;
            CONFIG.idleRotationSpeed = {
              x: rotSpeed * 0.6,
              y: rotSpeed,
              z: rotSpeed * 0.4
            };
            rotationSlider.value = rotSpeed;
            updateValueDisplay('rotation-speed', rotSpeed.toFixed(4));
          }

          if (settings.noiseAmplitude !== undefined) {
            CONFIG.noiseAmplitude = settings.noiseAmplitude;
            noiseAmpSlider.value = settings.noiseAmplitude;
            updateValueDisplay('noise-amplitude', settings.noiseAmplitude.toFixed(2));
          }

          if (settings.noiseFrequency !== undefined) {
            CONFIG.noiseFrequency = settings.noiseFrequency;
            noiseFreqSlider.value = settings.noiseFrequency;
            updateValueDisplay('noise-frequency', settings.noiseFrequency.toFixed(4));
          }

          if (settings.baseRadius !== undefined) {
            CONFIG.baseRadius = settings.baseRadius;
            CONFIG.expandedRadius = settings.baseRadius;
            radiusSlider.value = settings.baseRadius;
            updateValueDisplay('base-radius', settings.baseRadius, 'px');
          }

          if (settings.brightnessMultiplier !== undefined) {
            CONFIG.brightnessMultiplier = settings.brightnessMultiplier;
            brightnessSlider.value = settings.brightnessMultiplier;
            updateValueDisplay('brightness', settings.brightnessMultiplier.toFixed(2));
          }

          if (settings.lineWidth !== undefined) {
            CONFIG.lineWidth = settings.lineWidth;
            lineWidthSlider.value = settings.lineWidth;
            updateValueDisplay('line-width', settings.lineWidth.toFixed(1));
          }

          if (settings.baseOpacity !== undefined) {
            CONFIG.baseOpacity = settings.baseOpacity;
            lineOpacitySlider.value = settings.baseOpacity;
            updateValueDisplay('line-opacity', settings.baseOpacity.toFixed(2));
          }
        } catch (e) {
          console.error('Failed to load settings:', e);
        }
      }
    }

    // Reset to defaults
    resetBtn.addEventListener('click', () => {
      CONFIG.gridResolution = { ...DEFAULT_CONFIG.gridResolution };
      CONFIG.morphSpeed = DEFAULT_CONFIG.morphSpeed;
      CONFIG.idleRotationSpeed = { ...DEFAULT_CONFIG.idleRotationSpeed };
      CONFIG.noiseAmplitude = DEFAULT_CONFIG.noiseAmplitude;
      CONFIG.noiseFrequency = DEFAULT_CONFIG.noiseFrequency;
      CONFIG.baseRadius = DEFAULT_CONFIG.baseRadius;
      CONFIG.expandedRadius = DEFAULT_CONFIG.baseRadius;
      CONFIG.brightnessMultiplier = DEFAULT_CONFIG.brightnessMultiplier;
      CONFIG.lineWidth = DEFAULT_CONFIG.lineWidth;
      CONFIG.baseOpacity = DEFAULT_CONFIG.baseOpacity;

      // Update all sliders (grid resolution is hidden)
      gridSlider.value = DEFAULT_CONFIG.gridResolution.lat;
      updateValueDisplay('grid-resolution', DEFAULT_CONFIG.gridResolution.lat);

      morphSlider.value = DEFAULT_CONFIG.morphSpeed;
      updateValueDisplay('morph-speed', DEFAULT_CONFIG.morphSpeed.toFixed(3));

      rotationSlider.value = DEFAULT_CONFIG.idleRotationSpeed.y;
      updateValueDisplay('rotation-speed', DEFAULT_CONFIG.idleRotationSpeed.y.toFixed(4));

      noiseAmpSlider.value = DEFAULT_CONFIG.noiseAmplitude;
      updateValueDisplay('noise-amplitude', DEFAULT_CONFIG.noiseAmplitude.toFixed(2));

      noiseFreqSlider.value = DEFAULT_CONFIG.noiseFrequency;
      updateValueDisplay('noise-frequency', DEFAULT_CONFIG.noiseFrequency.toFixed(4));

      radiusSlider.value = DEFAULT_CONFIG.baseRadius;
      updateValueDisplay('base-radius', DEFAULT_CONFIG.baseRadius, 'px');

      brightnessSlider.value = DEFAULT_CONFIG.brightnessMultiplier;
      updateValueDisplay('brightness', DEFAULT_CONFIG.brightnessMultiplier.toFixed(2));

      lineWidthSlider.value = DEFAULT_CONFIG.lineWidth;
      updateValueDisplay('line-width', DEFAULT_CONFIG.lineWidth.toFixed(1));

      lineOpacitySlider.value = DEFAULT_CONFIG.baseOpacity;
      updateValueDisplay('line-opacity', DEFAULT_CONFIG.baseOpacity.toFixed(2));

      regenerateBlobMesh();
      saveSettings();
    });

    // Load saved settings on page load
    loadSettings();

    // ==========================================
    // BLOB RENDERING
    // ==========================================
    let time = 0;
    let lastFrameTime = 0;

    function renderBlob(currentTime) {
      if (currentTime - lastFrameTime < frameInterval) {
        requestAnimationFrame(renderBlob);
        return;
      }
      lastFrameTime = currentTime;

      // Only morph when not scrolling
      if (!isScrolling) {
        time += CONFIG.morphSpeed;
      }

      // Clear canvas
      blobCtx.clearRect(0, 0, blobCanvas.width, blobCanvas.height);

      // Update rotation - combine idle rotation with scroll-based rotation
      if (isScrolling) {
        // During scroll, use scroll-based rotation
        rotation.y = scrollRotation;
        rotation.x += CONFIG.idleRotationSpeed.x * 0.5; // Minimal idle rotation
        rotation.z += CONFIG.idleRotationSpeed.z * 0.5;
      } else {
        // When idle, use slow automatic rotation
        rotation.x += CONFIG.idleRotationSpeed.x;
        rotation.y += CONFIG.idleRotationSpeed.y;
        rotation.z += CONFIG.idleRotationSpeed.z;
      }

      // Update vertices
      vertices.forEach(vertex => {
        // Apply noise to radius
        const noiseValue = simplex.noise3D(
          Math.cos(vertex.phi) * Math.sin(vertex.theta) + time * CONFIG.noiseFrequency * 100,
          Math.sin(vertex.phi) * Math.sin(vertex.theta) + time * CONFIG.noiseFrequency * 100,
          Math.cos(vertex.theta) + time * CONFIG.noiseFrequency * 100
        );

        const radius = currentRadius * (1 + noiseValue * CONFIG.noiseAmplitude);

        // Spherical to Cartesian
        let x = radius * Math.sin(vertex.theta) * Math.cos(vertex.phi);
        let y = radius * Math.sin(vertex.theta) * Math.sin(vertex.phi);
        let z = radius * Math.cos(vertex.theta);

        // Apply rotations
        let rotated = rotateX(x, y, z, rotation.x);
        rotated = rotateY(rotated.x, rotated.y, rotated.z, rotation.y);
        rotated = rotateZ(rotated.x, rotated.y, rotated.z, rotation.z);

        vertex.x = rotated.x;
        vertex.y = rotated.y;
        vertex.z = rotated.z;

        // Project to 2D
        vertex.projected = project3D(rotated.x, rotated.y, rotated.z, currentRadius);
      });

      // Sort vertices by Z (back to front)
      const sortedVertices = [...vertices].sort((a, b) => a.z - b.z);

      // Light direction (from top-right-front)
      const lightDir = { x: 0.5, y: -0.5, z: 1 };
      const lightMag = Math.sqrt(lightDir.x ** 2 + lightDir.y ** 2 + lightDir.z ** 2);
      const lightNorm = { x: lightDir.x / lightMag, y: lightDir.y / lightMag, z: lightDir.z / lightMag };

      // Calculate normals for each vertex
      vertices.forEach(vertex => {
        // Normal is just the normalized position vector for a sphere
        const mag = Math.sqrt(vertex.x ** 2 + vertex.y ** 2 + vertex.z ** 2);
        vertex.normal = {
          x: vertex.x / mag,
          y: vertex.y / mag,
          z: vertex.z / mag,
        };
        // Calculate lighting (dot product with light direction)
        vertex.lighting = Math.max(0, vertex.normal.x * lightNorm.x + vertex.normal.y * lightNorm.y + vertex.normal.z * lightNorm.z);
      });

      // Draw wireframe with adjustable line width
      blobCtx.lineWidth = CONFIG.lineWidth;

      // Apply brightness adjustment to current color
      const adjustedColor = adjustBrightness(currentColor, CONFIG.brightnessMultiplier);

      // Draw latitude lines
      for (let lat = 0; lat <= CONFIG.gridResolution.lat; lat++) {
        blobCtx.beginPath();
        for (let lon = 0; lon <= CONFIG.gridResolution.lon; lon++) {
          const index = lat * (CONFIG.gridResolution.lon + 1) + lon;
          const vertex = vertices[index];

          // Improved shading: combine Z-depth and normal-based lighting
          const depthFade = (vertex.z / currentRadius + 1) / 2; // 0 (back) to 1 (front)
          const lighting = vertex.lighting; // 0 (dark) to 1 (bright)

          // Base opacity uses adjustable value, increases with lighting and depth
          const lightBoost = lighting * 0.4;
          const depthBoost = depthFade * 0.25;
          const opacity = CONFIG.baseOpacity + lightBoost + depthBoost;

          blobCtx.strokeStyle = adjustedColor + Math.floor(opacity * 255).toString(16).padStart(2, '0');

          if (lon === 0) {
            blobCtx.moveTo(vertex.projected.x, vertex.projected.y);
          } else {
            blobCtx.lineTo(vertex.projected.x, vertex.projected.y);
          }
        }
        blobCtx.stroke();
      }

      // Draw longitude lines
      for (let lon = 0; lon <= CONFIG.gridResolution.lon; lon++) {
        blobCtx.beginPath();
        for (let lat = 0; lat <= CONFIG.gridResolution.lat; lat++) {
          const index = lat * (CONFIG.gridResolution.lon + 1) + lon;
          const vertex = vertices[index];

          const depthFade = (vertex.z / currentRadius + 1) / 2;
          const lighting = vertex.lighting;

          const lightBoost = lighting * 0.4;
          const depthBoost = depthFade * 0.25;
          const opacity = CONFIG.baseOpacity + lightBoost + depthBoost;

          blobCtx.strokeStyle = adjustedColor + Math.floor(opacity * 255).toString(16).padStart(2, '0');

          if (lat === 0) {
            blobCtx.moveTo(vertex.projected.x, vertex.projected.y);
          } else {
            blobCtx.lineTo(vertex.projected.x, vertex.projected.y);
          }
        }
        blobCtx.stroke();
      }

      requestAnimationFrame(renderBlob);
    }

    // ==========================================
    // ANIMATION LOOP
    // ==========================================
    function animate(currentTime) {
      renderStarfield(currentTime * 0.001);
      requestAnimationFrame(animate);
    }

    // Start animations
    requestAnimationFrame(animate);
    requestAnimationFrame(renderBlob);
  </script>
</body>
</html>
